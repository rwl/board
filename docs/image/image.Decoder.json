{"name":"Decoder","qualifiedName":"image/image.Decoder","comment":"<p>Base class for image format decoders.</p>\n<p>Image pixels are stored as 32-bit unsigned ints, so all formats, regardless\nof their encoded color resolutions, decode to 32-bit RGBA images.  Encoders\ncan reduce the color resolution back down to their required formats.</p>\n<p>Some image formats support multiple frames, often for encoding animation.\nIn such cases, the <a>image/image.Decoder.decodeImage</a> method will decode the first (or otherwise\nspecified with the frame parameter) frame of the file.  <a>image/image.Decoder.decodeAnimation</a>\nwill decode all frames from the image.  <a>image/image.Decoder.startDecode</a> will initiate\ndecoding of the file, and <a>image/image.Decoder.decodeFrame</a> will then decode a specific frame\nfrom the file, allowing for animations to be decoded one frame at a time.\nSome formats, such as TIFF, may store multiple frames, but their use of\nframes is for multiple page documents and not animation.  The terms\n'animation' and 'frames' simply refer to 'pages' in this case.</p>\n<p>If an image file does not have multiple frames, <a>image/image.Decoder.decodeAnimation</a> and\n<a>image/image.Decoder.startDecode</a>/<a>image/image.Decoder.decodeFrame</a> will return the single image of the\nfile. As such, if you are not sure if a file is animated or not, you can\nuse the animated functions and process it as a single frame image if it\nhas only 1 frame, and as an animation if it has more than 1 frame.</p>\n<p>Most animated formats do not store full images for frames, but rather\nsome frames will store full images and others will store partial 'change'\nimages. For these files, <a>image/image.Decoder.decodeAnimation</a> will always return all images\nfully composited, meaning full frame images.  Decoding frames individually\nusing <a>image/image.Decoder.startDecode</a> and <a>image/image.Decoder.decodeFrame</a> will return the potentially partial\nimage.  In this case, the <a>image/image.DecodeInfo</a> returned by <a>image/image.Decoder.startDecode</a> will include\nthe width and height resolution of the animation canvas, and each <a>image/image.Image</a>\nreturned by <a>image/image.Decoder.decodeFrame</a> will have x, y, width and height properties\nindicating where in the canvas the frame image should be drawn.  It will\nalso have a disposeMethod property that specifies what should be done to\nthe canvas prior to drawing the frame: <a>image/image.Image.DISPOSE_NONE</a> indicates the\ncanvas should be left alone; <a>image/image.Image.DISPOSE_CLEAR</a> indicates the canvas\nshould be cleared.  For partial frame images,<a>image/image.Image.DISPOSE_NONE</a> is used\nso that the partial-frame is drawn on top of the previous frame, applying\nit's changes to the image.</p>","isAbstract":true,"superclass":"dart-core.Object","implements":[],"subclass":["image/image.ExrDecoder","image/image.GifDecoder","image/image.JpegDecoder","image/image.PngDecoder","image/image.PsdDecoder","image/image.TgaDecoder","image/image.TiffDecoder","image/image.WebPDecoder"],"variables":{"progressCallback":{"name":"progressCallback","qualifiedName":"image/image.Decoder.progressCallback","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"image/image.ProgressCallback","inner":[]}],"annotations":[]}},"inheritedVariables":{},"methods":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"decodeAnimation":{"name":"decodeAnimation","qualifiedName":"image/image.Decoder.decodeAnimation","comment":"<p>Decode all of the frames from an animation.  If the file is not an\nanimation, a single frame animation is returned.  If there was a problem\ndecoding the file, null is returned.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"image/image.Animation","inner":[]}],"parameters":{"bytes":{"name":"bytes","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"decodeFrame":{"name":"decodeFrame","qualifiedName":"image/image.Decoder.decodeFrame","comment":"<p>Decode a single frame from the data that was set with <a>image/image.Decoder.startDecode</a>.\nIf <a>image/image.Decoder.decodeFrame.frame</a> is out of the range of available frames, null is returned.\nNon animated image files will only have <a>image/image.Decoder.decodeFrame.frame</a> 0. An <a>image/image.Image</a>\nis returned, which provides the image, and top-left coordinates of the\nimage, as animated frames may only occupy a subset of the canvas.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"image/image.Image","inner":[]}],"parameters":{"frame":{"name":"frame","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"decodeHdrFrame":{"name":"decodeHdrFrame","qualifiedName":"image/image.Decoder.decodeHdrFrame","comment":"<p>Decode a single high dynamic range (HDR) frame from the data that was set\nwith <a>image/image.Decoder.startDecode</a>. If the format of the file does not support HDR images,\nthe regular image will be converted to an HDR image as (color / 255).\nIf <a>image/image.Decoder.decodeHdrFrame.frame</a> is out of the range of available frames, null is returned.\nNon animated image files will only have <a>image/image.Decoder.decodeHdrFrame.frame</a> 0. An <a>image/image.Image</a>\nis returned, which provides the image, and top-left coordinates of the\nimage, as animated frames may only occupy a subset of the canvas.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"image/image.HdrImage","inner":[]}],"parameters":{"frame":{"name":"frame","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"decodeHdrImage":{"name":"decodeHdrImage","qualifiedName":"image/image.Decoder.decodeHdrImage","comment":"<p>Decode the file and extract a single High Dynamic Range (HDR) image from\nit. HDR images are stored in floating-poing values. If the format of the\nfile does not support HDR images, the regular image will be converted to\nan HDR image as (color / 255). If the file is animated, the specified\n<a>image/image.Decoder.decodeHdrImage.frame</a> will be decoded. If there was a problem decoding the file, null is\nreturned.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"image/image.HdrImage","inner":[]}],"parameters":{"bytes":{"name":"bytes","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]},"frame":{"name":"frame","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]}},"annotations":[]},"decodeImage":{"name":"decodeImage","qualifiedName":"image/image.Decoder.decodeImage","comment":"<p>Decode the file and extract a single image from it. If the file is\nanimated, the specified <a>image/image.Decoder.decodeImage.frame</a> will be decoded. If there was a problem\ndecoding the file, null is returned.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"image/image.Image","inner":[]}],"parameters":{"bytes":{"name":"bytes","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]},"frame":{"name":"frame","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]}},"annotations":[]},"isValidFile":{"name":"isValidFile","qualifiedName":"image/image.Decoder.isValidFile","comment":"<p>A light-weight function to test if the given file is able to be decoded\nby this Decoder.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"bytes":{"name":"bytes","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"numFrames":{"name":"numFrames","qualifiedName":"image/image.Decoder.numFrames","comment":"<p>How many frames are available to be decoded.  <a>image/image.Decoder.startDecode</a> should have\nbeen called first. Non animated image files will have a single frame.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"startDecode":{"name":"startDecode","qualifiedName":"image/image.Decoder.startDecode","comment":"<p>Start decoding the data as an animation sequence, but don't actually\nprocess the frames until they are requested with decodeFrame.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"image/image.DecodeInfo","inner":[]}],"parameters":{"bytes":{"name":"bytes","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"image/image.Decoder.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>image/image.Decoder.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"image/image.Decoder.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"image/image.Decoder.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>image/image.Decoder.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>image/image.Decoder.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"image/image.Decoder.noSuchMethod","comment":"<p><a>image/image.Decoder.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>image/image.Decoder.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>image/image.Decoder.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>image/image.Decoder.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"image/image.Decoder.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}