{"name":"ExrDecoder","qualifiedName":"image/image.ExrDecoder","comment":"<p>Decode an OpenEXR formatted image.</p>\n<p>OpenEXR is a format developed by Industrial Light &amp; Magic, with collaboration\nfrom other companies such as Weta and Pixar, for storing hight dynamic\nrange (HDR) images for use in digital visual effects production. It supports\na wide range of features, including 16-bit or 32-bit floating-point channels;\nlossless and lossy data compression; arbitrary image channels for storing\nany combination of data, such as red, green, blue, alpha, luminance and\nchroma channels, depth, surface normal, motion vectors, etc. It can also\nstore images in scanline or tiled format; multiple views for stereo images;\nmultiple parts; etc.</p>\n<p>Because OpenEXR is a high-dynamic-range (HDR) format, it must be converted\nto a low-dynamic-range (LDR) image for display, or for use as an OpenGL\ntexture (for example). This process is called tone-mapping. Currently only\na simple tone-mapping function is provided with a single <a>image/image.ExrDecoder.exposure</a>\nparameter. More tone-mapping functionality will be added.</p>","isAbstract":false,"superclass":"image/image.Decoder","implements":[],"subclass":[],"variables":{"bloomAmount":{"name":"bloomAmount","qualifiedName":"image/image.ExrDecoder.bloomAmount","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.double","inner":[]}],"annotations":[]},"bloomRadius":{"name":"bloomRadius","qualifiedName":"image/image.ExrDecoder.bloomRadius","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.double","inner":[]}],"annotations":[]},"exposure":{"name":"exposure","qualifiedName":"image/image.ExrDecoder.exposure","comment":"<p>Exposure for tone-mapping the hdr image to an <a>image/image.Image</a>, applied during\n<a>image/image.ExrDecoder.decodeFrame</a>.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.double","inner":[]}],"annotations":[]},"exrImage":{"name":"exrImage","qualifiedName":"image/image.ExrDecoder.exrImage","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"image/image.ExrImage","inner":[]}],"annotations":[]},"gamma":{"name":"gamma","qualifiedName":"image/image.ExrDecoder.gamma","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.double","inner":[]}],"annotations":[]},"reinhard":{"name":"reinhard","qualifiedName":"image/image.ExrDecoder.reinhard","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.bool","inner":[]}],"annotations":[]}},"inheritedVariables":{"progressCallback":{"name":"progressCallback","qualifiedName":"image/image.Decoder.progressCallback","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"image/image.ProgressCallback","inner":[]}],"annotations":[]}},"methods":{"setters":{},"getters":{},"constructors":{"":{"name":"","qualifiedName":"image/image.ExrDecoder.ExrDecoder-","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"exposure":{"name":"exposure","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.double","inner":[]}],"value":"1.0","annotations":[]}},"annotations":[]}},"operators":{},"methods":{"decodeAnimation":{"name":"decodeAnimation","qualifiedName":"image/image.ExrDecoder.decodeAnimation","comment":"<p>Decode all of the frames from an animation.  If the file is not an\nanimation, a single frame animation is returned.  If there was a problem\ndecoding the file, null is returned.</p>","commentFrom":"image.Decoder.decodeAnimation","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"image/image.Animation","inner":[]}],"parameters":{"data":{"name":"data","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"decodeFrame":{"name":"decodeFrame","qualifiedName":"image/image.ExrDecoder.decodeFrame","comment":"<p>Decode a single frame from the data that was set with <a>image/image.ExrDecoder.startDecode</a>.\nIf <a>image/image.ExrDecoder.decodeFrame.frame</a> is out of the range of available frames, null is returned.\nNon animated image files will only have <a>image/image.ExrDecoder.decodeFrame.frame</a> 0. An <a>image/image.Image</a>\nis returned, which provides the image, and top-left coordinates of the\nimage, as animated frames may only occupy a subset of the canvas.</p>","commentFrom":"image.Decoder.decodeFrame","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"image/image.Image","inner":[]}],"parameters":{"frame":{"name":"frame","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"decodeHdrFrame":{"name":"decodeHdrFrame","qualifiedName":"image/image.ExrDecoder.decodeHdrFrame","comment":"<p>Decode a single high dynamic range (HDR) frame from the data that was set\nwith <a>image/image.ExrDecoder.startDecode</a>. If the format of the file does not support HDR images,\nthe regular image will be converted to an HDR image as (color / 255).\nIf <a>image/image.ExrDecoder.decodeHdrFrame.frame</a> is out of the range of available frames, null is returned.\nNon animated image files will only have <a>image/image.ExrDecoder.decodeHdrFrame.frame</a> 0. An <a>image/image.Image</a>\nis returned, which provides the image, and top-left coordinates of the\nimage, as animated frames may only occupy a subset of the canvas.</p>","commentFrom":"image.Decoder.decodeHdrFrame","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"image/image.HdrImage","inner":[]}],"parameters":{"frame":{"name":"frame","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"decodeHdrImage":{"name":"decodeHdrImage","qualifiedName":"image/image.ExrDecoder.decodeHdrImage","comment":"<p>Decode the file and extract a single High Dynamic Range (HDR) image from\nit. HDR images are stored in floating-poing values. If the format of the\nfile does not support HDR images, the regular image will be converted to\nan HDR image as (color / 255). If the file is animated, the specified\n<a>image/image.ExrDecoder.decodeHdrImage.frame</a> will be decoded. If there was a problem decoding the file, null is\nreturned.</p>","commentFrom":"image.Decoder.decodeHdrImage","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"image/image.HdrImage","inner":[]}],"parameters":{"bytes":{"name":"bytes","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]},"frame":{"name":"frame","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]}},"annotations":[]},"decodeImage":{"name":"decodeImage","qualifiedName":"image/image.ExrDecoder.decodeImage","comment":"<p>Decode the file and extract a single image from it. If the file is\nanimated, the specified <a>image/image.ExrDecoder.decodeImage.frame</a> will be decoded. If there was a problem\ndecoding the file, null is returned.</p>","commentFrom":"image.Decoder.decodeImage","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"image/image.Image","inner":[]}],"parameters":{"bytes":{"name":"bytes","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]},"frame":{"name":"frame","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]}},"annotations":[]},"isValidFile":{"name":"isValidFile","qualifiedName":"image/image.ExrDecoder.isValidFile","comment":"<p>A light-weight function to test if the given file is able to be decoded\nby this Decoder.</p>","commentFrom":"image.Decoder.isValidFile","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"data":{"name":"data","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"numFrames":{"name":"numFrames","qualifiedName":"image/image.ExrDecoder.numFrames","comment":"<p>How many frames are available to be decoded.  <a>image/image.ExrDecoder.startDecode</a> should have\nbeen called first. Non animated image files will have a single frame.</p>","commentFrom":"image.Decoder.numFrames","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"startDecode":{"name":"startDecode","qualifiedName":"image/image.ExrDecoder.startDecode","comment":"<p>Start decoding the data as an animation sequence, but don't actually\nprocess the frames until they are requested with decodeFrame.</p>","commentFrom":"image.Decoder.startDecode","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"image/image.DecodeInfo","inner":[]}],"parameters":{"data":{"name":"data","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"image/image.ExrDecoder.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>image/image.ExrDecoder.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"image/image.ExrDecoder.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"image/image.ExrDecoder.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>image/image.ExrDecoder.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>image/image.ExrDecoder.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"decodeAnimation":{"name":"decodeAnimation","qualifiedName":"image/image.ExrDecoder.decodeAnimation","comment":"<p>Decode all of the frames from an animation.  If the file is not an\nanimation, a single frame animation is returned.  If there was a problem\ndecoding the file, null is returned.</p>","commentFrom":"","inheritedFrom":"image.Decoder.decodeAnimation","static":false,"abstract":true,"constant":false,"return":[{"outer":"image/image.Animation","inner":[]}],"parameters":{"bytes":{"name":"bytes","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"decodeFrame":{"name":"decodeFrame","qualifiedName":"image/image.ExrDecoder.decodeFrame","comment":"<p>Decode a single frame from the data that was set with <a>image/image.ExrDecoder.startDecode</a>.\nIf <a>image/image.ExrDecoder.decodeFrame.frame</a> is out of the range of available frames, null is returned.\nNon animated image files will only have <a>image/image.ExrDecoder.decodeFrame.frame</a> 0. An <a>image/image.Image</a>\nis returned, which provides the image, and top-left coordinates of the\nimage, as animated frames may only occupy a subset of the canvas.</p>","commentFrom":"","inheritedFrom":"image.Decoder.decodeFrame","static":false,"abstract":true,"constant":false,"return":[{"outer":"image/image.Image","inner":[]}],"parameters":{"frame":{"name":"frame","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"decodeHdrFrame":{"name":"decodeHdrFrame","qualifiedName":"image/image.ExrDecoder.decodeHdrFrame","comment":"<p>Decode a single high dynamic range (HDR) frame from the data that was set\nwith <a>image/image.ExrDecoder.startDecode</a>. If the format of the file does not support HDR images,\nthe regular image will be converted to an HDR image as (color / 255).\nIf <a>image/image.ExrDecoder.decodeHdrFrame.frame</a> is out of the range of available frames, null is returned.\nNon animated image files will only have <a>image/image.ExrDecoder.decodeHdrFrame.frame</a> 0. An <a>image/image.Image</a>\nis returned, which provides the image, and top-left coordinates of the\nimage, as animated frames may only occupy a subset of the canvas.</p>","commentFrom":"","inheritedFrom":"image.Decoder.decodeHdrFrame","static":false,"abstract":false,"constant":false,"return":[{"outer":"image/image.HdrImage","inner":[]}],"parameters":{"frame":{"name":"frame","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"decodeHdrImage":{"name":"decodeHdrImage","qualifiedName":"image/image.ExrDecoder.decodeHdrImage","comment":"<p>Decode the file and extract a single High Dynamic Range (HDR) image from\nit. HDR images are stored in floating-poing values. If the format of the\nfile does not support HDR images, the regular image will be converted to\nan HDR image as (color / 255). If the file is animated, the specified\n<a>image/image.ExrDecoder.decodeHdrImage.frame</a> will be decoded. If there was a problem decoding the file, null is\nreturned.</p>","commentFrom":"","inheritedFrom":"image.Decoder.decodeHdrImage","static":false,"abstract":false,"constant":false,"return":[{"outer":"image/image.HdrImage","inner":[]}],"parameters":{"bytes":{"name":"bytes","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]},"frame":{"name":"frame","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]}},"annotations":[]},"decodeImage":{"name":"decodeImage","qualifiedName":"image/image.ExrDecoder.decodeImage","comment":"<p>Decode the file and extract a single image from it. If the file is\nanimated, the specified <a>image/image.ExrDecoder.decodeImage.frame</a> will be decoded. If there was a problem\ndecoding the file, null is returned.</p>","commentFrom":"","inheritedFrom":"image.Decoder.decodeImage","static":false,"abstract":true,"constant":false,"return":[{"outer":"image/image.Image","inner":[]}],"parameters":{"bytes":{"name":"bytes","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]},"frame":{"name":"frame","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]}},"annotations":[]},"isValidFile":{"name":"isValidFile","qualifiedName":"image/image.ExrDecoder.isValidFile","comment":"<p>A light-weight function to test if the given file is able to be decoded\nby this Decoder.</p>","commentFrom":"","inheritedFrom":"image.Decoder.isValidFile","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"bytes":{"name":"bytes","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"image/image.ExrDecoder.noSuchMethod","comment":"<p><a>image/image.ExrDecoder.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>image/image.ExrDecoder.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>image/image.ExrDecoder.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>image/image.ExrDecoder.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"numFrames":{"name":"numFrames","qualifiedName":"image/image.ExrDecoder.numFrames","comment":"<p>How many frames are available to be decoded.  <a>image/image.ExrDecoder.startDecode</a> should have\nbeen called first. Non animated image files will have a single frame.</p>","commentFrom":"","inheritedFrom":"image.Decoder.numFrames","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"startDecode":{"name":"startDecode","qualifiedName":"image/image.ExrDecoder.startDecode","comment":"<p>Start decoding the data as an animation sequence, but don't actually\nprocess the frames until they are requested with decodeFrame.</p>","commentFrom":"","inheritedFrom":"image.Decoder.startDecode","static":false,"abstract":true,"constant":false,"return":[{"outer":"image/image.DecodeInfo","inner":[]}],"parameters":{"bytes":{"name":"bytes","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"image/image.ExrDecoder.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}