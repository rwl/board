{"name":"matcher","qualifiedName":"matcher/matcher","comment":"<p>Support for specifying test expectations, such as for unit tests.</p>\n<p>The matcher library provides a third-generation assertion mechanism, drawing\ninspiration from <a href=\"http://code.google.com/p/hamcrest/\">Hamcrest</a>.</p>\n<p>For more information, see\n<a href=\"http://www.dartlang.org/articles/dart-unit-tests/\">Unit Testing with Dart</a>.</p>","variables":{"anything":{"name":"anything","qualifiedName":"matcher/matcher.anything","comment":"<p>A matcher that matches any value.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"completes":{"name":"completes","qualifiedName":"matcher/matcher.completes","comment":"<p>Matches a <a>dart-async.Future</a> that completes successfully with a value. Note that this\ncreates an asynchronous expectation. The call to <code>expect()</code> that includes\nthis will return immediately and execution will continue. Later, when the\nfuture completes, the actual expectation will run.</p>\n<p>To test that a Future completes with an exception, you can use <a>matcher/matcher.throws</a> and\n<a>matcher/matcher.throwsA</a>.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isAbstractClassInstantiationError":{"name":"isAbstractClassInstantiationError","qualifiedName":"matcher/matcher.isAbstractClassInstantiationError","comment":"<p>A matcher for AbstractClassInstantiationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isArgumentError":{"name":"isArgumentError","qualifiedName":"matcher/matcher.isArgumentError","comment":"<p>A matcher for ArgumentErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isConcurrentModificationError":{"name":"isConcurrentModificationError","qualifiedName":"matcher/matcher.isConcurrentModificationError","comment":"<p>A matcher for ConcurrentModificationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isCyclicInitializationError":{"name":"isCyclicInitializationError","qualifiedName":"matcher/matcher.isCyclicInitializationError","comment":"<p>A matcher for CyclicInitializationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isEmpty":{"name":"isEmpty","qualifiedName":"matcher/matcher.isEmpty","comment":"<p>Returns a matcher that matches empty strings, maps or iterables\n(including collections).</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isException":{"name":"isException","qualifiedName":"matcher/matcher.isException","comment":"<p>A matcher for Exceptions.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isFallThroughError":{"name":"isFallThroughError","qualifiedName":"matcher/matcher.isFallThroughError","comment":"<p>A matcher for FallThroughError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isFalse":{"name":"isFalse","qualifiedName":"matcher/matcher.isFalse","comment":"<p>A matcher that matches anything except the Boolean value true.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isFormatException":{"name":"isFormatException","qualifiedName":"matcher/matcher.isFormatException","comment":"<p>A matcher for FormatExceptions.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isList":{"name":"isList","qualifiedName":"matcher/matcher.isList","comment":"<p>A matcher for List types.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isMap":{"name":"isMap","qualifiedName":"matcher/matcher.isMap","comment":"<p>A matcher for Map types.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isNegative":{"name":"isNegative","qualifiedName":"matcher/matcher.isNegative","comment":"<p>A matcher which matches if the match argument is negative.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNoSuchMethodError":{"name":"isNoSuchMethodError","qualifiedName":"matcher/matcher.isNoSuchMethodError","comment":"<p>A matcher for NoSuchMethodErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isNonNegative":{"name":"isNonNegative","qualifiedName":"matcher/matcher.isNonNegative","comment":"<p>A matcher which matches if the match argument is zero or positive.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNonPositive":{"name":"isNonPositive","qualifiedName":"matcher/matcher.isNonPositive","comment":"<p>A matcher which matches if the match argument is zero or negative.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNonZero":{"name":"isNonZero","qualifiedName":"matcher/matcher.isNonZero","comment":"<p>A matcher which matches if the match argument is non-zero.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNotNull":{"name":"isNotNull","qualifiedName":"matcher/matcher.isNotNull","comment":"<p>A matcher that matches any non-null value.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNull":{"name":"isNull","qualifiedName":"matcher/matcher.isNull","comment":"<p>A matcher that matches any null value.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isNullThrownError":{"name":"isNullThrownError","qualifiedName":"matcher/matcher.isNullThrownError","comment":"<p>A matcher for NullThrownError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isPositive":{"name":"isPositive","qualifiedName":"matcher/matcher.isPositive","comment":"<p>A matcher which matches if the match argument is positive.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isRangeError":{"name":"isRangeError","qualifiedName":"matcher/matcher.isRangeError","comment":"<p>A matcher for RangeErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isStateError":{"name":"isStateError","qualifiedName":"matcher/matcher.isStateError","comment":"<p>A matcher for StateErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isTrue":{"name":"isTrue","qualifiedName":"matcher/matcher.isTrue","comment":"<p>A matcher that matches the Boolean value true.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"isUnimplementedError":{"name":"isUnimplementedError","qualifiedName":"matcher/matcher.isUnimplementedError","comment":"<p>A matcher for UnimplementedErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isUnsupportedError":{"name":"isUnsupportedError","qualifiedName":"matcher/matcher.isUnsupportedError","comment":"<p>A matcher for UnsupportedError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isZero":{"name":"isZero","qualifiedName":"matcher/matcher.isZero","comment":"<p>A matcher which matches if the match argument is zero.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"returnsNormally":{"name":"returnsNormally","qualifiedName":"matcher/matcher.returnsNormally","comment":"<p>A matcher that matches a function call against no exception.\nThe function will be called once. Any exceptions will be silently swallowed.\nThe value passed to expect() should be a reference to the function.\nNote that the function cannot take arguments; to handle this\na wrapper will have to be created.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throws":{"name":"throws","qualifiedName":"matcher/matcher.throws","comment":"<p>This can be used to match two kinds of objects:</p><ul><li>\n<p>A <a>dart-core.Function</a> that throws an exception when called. The function cannot\ntake any arguments. If you want to test that a function expecting\narguments throws, wrap it in another zero-argument function that calls\nthe one you want to test.</p></li><li>\n<p>A <a>dart-async.Future</a> that completes with an exception. Note that this creates an\nasynchronous expectation. The call to <code>expect()</code> that includes this will\nreturn immediately and execution will continue. Later, when the future\ncompletes, the actual expectation will run.</p></li></ul>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsAbstractClassInstantiationError":{"name":"throwsAbstractClassInstantiationError","qualifiedName":"matcher/matcher.throwsAbstractClassInstantiationError","comment":"<p>A matcher for functions that throw AbstractClassInstantiationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsArgumentError":{"name":"throwsArgumentError","qualifiedName":"matcher/matcher.throwsArgumentError","comment":"<p>A matcher for functions that throw ArgumentError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsConcurrentModificationError":{"name":"throwsConcurrentModificationError","qualifiedName":"matcher/matcher.throwsConcurrentModificationError","comment":"<p>A matcher for functions that throw ConcurrentModificationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsCyclicInitializationError":{"name":"throwsCyclicInitializationError","qualifiedName":"matcher/matcher.throwsCyclicInitializationError","comment":"<p>A matcher for functions that throw CyclicInitializationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsException":{"name":"throwsException","qualifiedName":"matcher/matcher.throwsException","comment":"<p>A matcher for functions that throw Exception.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsFallThroughError":{"name":"throwsFallThroughError","qualifiedName":"matcher/matcher.throwsFallThroughError","comment":"<p>A matcher for functions that throw FallThroughError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsFormatException":{"name":"throwsFormatException","qualifiedName":"matcher/matcher.throwsFormatException","comment":"<p>A matcher for functions that throw FormatException.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsNoSuchMethodError":{"name":"throwsNoSuchMethodError","qualifiedName":"matcher/matcher.throwsNoSuchMethodError","comment":"<p>A matcher for functions that throw NoSuchMethodError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsNullThrownError":{"name":"throwsNullThrownError","qualifiedName":"matcher/matcher.throwsNullThrownError","comment":"<p>A matcher for functions that throw NullThrownError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsRangeError":{"name":"throwsRangeError","qualifiedName":"matcher/matcher.throwsRangeError","comment":"<p>A matcher for functions that throw RangeError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsStateError":{"name":"throwsStateError","qualifiedName":"matcher/matcher.throwsStateError","comment":"<p>A matcher for functions that throw StateError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsUnimplementedError":{"name":"throwsUnimplementedError","qualifiedName":"matcher/matcher.throwsUnimplementedError","comment":"<p>A matcher for functions that throw Exception.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"throwsUnsupportedError":{"name":"throwsUnsupportedError","qualifiedName":"matcher/matcher.throwsUnsupportedError","comment":"<p>A matcher for functions that throw UnsupportedError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"annotations":[]},"wrapAsync":{"name":"wrapAsync","qualifiedName":"matcher/matcher.wrapAsync","comment":"<p>Some matchers, like those for Futures and exception testing,\ncan fail in asynchronous sections, and throw exceptions.\nA user of this library will typically want to catch and handle\nsuch exceptions. The <a>matcher/matcher.wrapAsync</a> property is a function that\ncan wrap callbacks used by these Matchers so that they can be\nused safely. For example, the unittest library will set this\nto be <code>expectAsync</code>. By default this is an identity function.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.Function","inner":[]}],"annotations":[]}},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"addStateInfo":{"name":"addStateInfo","qualifiedName":"matcher/matcher.addStateInfo","comment":"<p>Useful utility for nesting match states.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"matchState":{"name":"matchState","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]},"values":{"name":"values","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"allOf":{"name":"allOf","qualifiedName":"matcher/matcher.allOf","comment":"<p>This returns a matcher that matches if all of the matchers passed as\narguments (up to 7) match. Instead of passing the matchers separately\nthey can be passed as a single List argument.\nAny argument that is not a matcher is implicitly wrapped in a\nMatcher to check for equality.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"arg0":{"name":"arg0","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"arg1":{"name":"arg1","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg2":{"name":"arg2","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg3":{"name":"arg3","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg4":{"name":"arg4","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg5":{"name":"arg5","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg6":{"name":"arg6","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"anyElement":{"name":"anyElement","qualifiedName":"matcher/matcher.anyElement","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s in which at least one\nelement matches the given <a>matcher/matcher.anyElement.matcher</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"anyOf":{"name":"anyOf","qualifiedName":"matcher/matcher.anyOf","comment":"<p>Matches if any of the given matchers evaluate to true. The\narguments can be a set of matchers as separate parameters\n(up to 7), or a List of matchers.</p>\n<p>The matchers are evaluated from left to right using short-circuit\nevaluation, so evaluation stops as soon as a matcher returns true.</p>\n<p>Any argument that is not a matcher is implicitly wrapped in a\nMatcher to check for equality.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"arg0":{"name":"arg0","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"arg1":{"name":"arg1","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg2":{"name":"arg2","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg3":{"name":"arg3","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg4":{"name":"arg4","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg5":{"name":"arg5","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg6":{"name":"arg6","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"closeTo":{"name":"closeTo","qualifiedName":"matcher/matcher.closeTo","comment":"<p>Returns a matcher which matches if the match argument is within <a>matcher/matcher.closeTo.delta</a>\nof some <a>matcher/matcher.closeTo.value</a>; i.e. if the match argument is greater than\nthan or equal <a>matcher/matcher.closeTo.value</a>-<a>matcher/matcher.closeTo.delta</a> and less than or equal to <a>matcher/matcher.closeTo.value</a>+<a>matcher/matcher.closeTo.delta</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"delta":{"name":"delta","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"collapseWhitespace":{"name":"collapseWhitespace","qualifiedName":"matcher/matcher.collapseWhitespace","comment":"<p>Utility function to collapse whitespace runs to single spaces\nand strip leading/trailing whitespace.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"_string":{"name":"_string","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"completion":{"name":"completion","qualifiedName":"matcher/matcher.completion","comment":"<p>Matches a <a>matcher/dart-async.Future</a> that completes succesfully with a value that matches\n<a>matcher/matcher.completion.matcher</a>. Note that this creates an asynchronous expectation. The call to\n<code>expect()</code> that includes this will return immediately and execution will\ncontinue. Later, when the future completes, the actual expectation will run.</p>\n<p>To test that a Future completes with an exception, you can use <a>matcher/matcher.throws</a> and\n<a>matcher/matcher.throwsA</a>.</p>\n<p><a>matcher/matcher.completion.id</a> is an optional tag that can be used to identify the completion matcher\nin error messages.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"id":{"name":"id","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.String","inner":[]}],"value":"\"\"","annotations":[]}},"annotations":[]},"configureExpectFailureHandler":{"name":"configureExpectFailureHandler","qualifiedName":"matcher/matcher.configureExpectFailureHandler","comment":"<p>Changes or resets to the default the failure handler for expect()\n<a>matcher/matcher.configureExpectFailureHandler.handler</a> is a reference to the new handler; if this is omitted\nor null then the failure handler is reset to the default, which\nthrows <a>matcher/matcher.TestFailure</a>s on <a>matcher/matcher.expect</a> assertion failures.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"handler":{"name":"handler","optional":true,"named":false,"default":true,"type":[{"outer":"matcher/matcher.FailureHandler","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"configureExpectFormatter":{"name":"configureExpectFormatter","qualifiedName":"matcher/matcher.configureExpectFormatter","comment":"<p>Changes or resets to default the failure message formatter for expect().\n<a>matcher/matcher.configureExpectFormatter.formatter</a> is a reference to the new formatter; if this is omitted or\nnull then the failure formatter is reset to the default. The new\nformatter is returned; this allows custom expect handlers to easily\nget a reference to the default formatter.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.ErrorFormatter","inner":[]}],"parameters":{"formatter":{"name":"formatter","optional":true,"named":false,"default":true,"type":[{"outer":"matcher/matcher.ErrorFormatter","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"contains":{"name":"contains","qualifiedName":"matcher/matcher.contains","comment":"<p>Returns a matcher that matches if the match argument contains\nthe expected value. For <a>dart-core.String</a>s this means substring matching;\nfor <a>dart-core.Map</a>s it means the map has the key, and for <a>dart-core.Iterable</a>s\n(including <a>dart-core.Iterable</a>s) it means the iterable has a matching\nelement. In the case of iterables, <a>matcher/matcher.contains.expected</a> can itself be a\nmatcher.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"containsPair":{"name":"containsPair","qualifiedName":"matcher/matcher.containsPair","comment":"<p>Returns a matcher which matches maps containing the key-value pair\nwith <a>matcher/matcher.containsPair.key</a> => <a>matcher/matcher.containsPair.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"key":{"name":"key","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"containsValue":{"name":"containsValue","qualifiedName":"matcher/matcher.containsValue","comment":"<p>Returns a matcher which matches maps containing the given <a>matcher/matcher.containsValue.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"endsWith":{"name":"endsWith","qualifiedName":"matcher/matcher.endsWith","comment":"<p>Returns a matcher that matches if the match argument is a string and\nends with <a>matcher/matcher.endsWith.suffixString</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"suffixString":{"name":"suffixString","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"equals":{"name":"equals","qualifiedName":"matcher/matcher.equals","comment":"<p>Returns a matcher that matches if the value is structurally equal to\n<a>matcher/matcher.equals.expected</a>.</p>\n<p>If <a>matcher/matcher.equals.expected</a> is a <a>matcher/matcher.Matcher</a>, then it matches using that. Otherwise it tests\nfor equality using <code>==</code> on the expected value.</p>\n<p>For <a>dart-core.Iterable</a>s and <a>dart-core.Map</a>s, this will recursively match the elements. To\nhandle cyclic structures a recursion depth <a>matcher/matcher.equals.limit</a> can be provided. The\ndefault limit is 100.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"limit":{"name":"limit","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"100","annotations":[]}},"annotations":[]},"equalsIgnoringCase":{"name":"equalsIgnoringCase","qualifiedName":"matcher/matcher.equalsIgnoringCase","comment":"<p>Returns a matcher which matches if the match argument is a string and\nis equal to <a>matcher/matcher.equalsIgnoringCase.value</a> when compared case-insensitively.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"equalsIgnoringWhitespace":{"name":"equalsIgnoringWhitespace","qualifiedName":"matcher/matcher.equalsIgnoringWhitespace","comment":"<p>Returns a matcher which matches if the match argument is a string and\nis equal to value when compared with all runs of whitespace\ncollapsed to single spaces and leading and trailing whitespace removed.</p>\n<p>For example, <code>equalsIgnoringCase(\"hello world\")</code> will match\n\"hello   world\", \"  hello world\" and \"hello world  \".</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"_string":{"name":"_string","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"everyElement":{"name":"everyElement","qualifiedName":"matcher/matcher.everyElement","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s in which all elements\nmatch the given <a>matcher/matcher.everyElement.matcher</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"expect":{"name":"expect","qualifiedName":"matcher/matcher.expect","comment":"<p>This is the main assertion function. It asserts that <a>matcher/matcher.expect.actual</a>\nmatches the <a>matcher/matcher.expect.matcher</a>. <a>matcher/matcher.expect.reason</a> is optional and is typically not\nsupplied, as a reason is generated from the matcher; if <a>matcher/matcher.expect.reason</a>\nis included it is appended to the reason generated by the matcher.</p>\n<p><a>matcher/matcher.expect.matcher</a> can be a value in which case it will be wrapped in an\n<a>matcher/matcher.equals</a> matcher.</p>\n<p>If the assertion fails, then the default behavior is to throw a\n<a>matcher/matcher.TestFailure</a>, but this behavior can be changed by calling\n<a>matcher/matcher.configureExpectFailureHandler</a> and providing an alternative handler that\nimplements the IFailureHandler interface. It is also possible to\npass a <a>matcher/matcher.expect.failureHandler</a> to <a>matcher/matcher.expect</a> as a final parameter for fine-\ngrained control.</p>\n<p>In some cases extra diagnostic info can be produced on failure (for\nexample, stack traces on mismatched exceptions). To enable these,\n<a>matcher/matcher.expect.verbose</a> should be specified as true;</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"actual":{"name":"actual","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"reason":{"name":"reason","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"failureHandler":{"name":"failureHandler","optional":true,"named":true,"default":false,"type":[{"outer":"matcher/matcher.FailureHandler","inner":[]}],"value":null,"annotations":[]},"verbose":{"name":"verbose","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"fail":{"name":"fail","qualifiedName":"matcher/matcher.fail","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"failureHandler":{"name":"failureHandler","optional":true,"named":true,"default":false,"type":[{"outer":"matcher/matcher.FailureHandler","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"getOrCreateExpectFailureHandler":{"name":"getOrCreateExpectFailureHandler","qualifiedName":"matcher/matcher.getOrCreateExpectFailureHandler","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.FailureHandler","inner":[]}],"parameters":{},"annotations":[]},"greaterThan":{"name":"greaterThan","qualifiedName":"matcher/matcher.greaterThan","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan the given <a>matcher/matcher.greaterThan.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"greaterThanOrEqualTo":{"name":"greaterThanOrEqualTo","qualifiedName":"matcher/matcher.greaterThanOrEqualTo","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan or equal to the given <a>matcher/matcher.greaterThanOrEqualTo.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"hasLength":{"name":"hasLength","qualifiedName":"matcher/matcher.hasLength","comment":"<p>Returns a matcher that matches if an object has a length property\nthat matches <a>matcher/matcher.hasLength.matcher</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inClosedOpenRange":{"name":"inClosedOpenRange","qualifiedName":"matcher/matcher.inClosedOpenRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan or equal to a <a>matcher/matcher.inClosedOpenRange.low</a> and less than <a>matcher/matcher.inClosedOpenRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inExclusiveRange":{"name":"inExclusiveRange","qualifiedName":"matcher/matcher.inExclusiveRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan <a>matcher/matcher.inExclusiveRange.low</a> and less than <a>matcher/matcher.inExclusiveRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inInclusiveRange":{"name":"inInclusiveRange","qualifiedName":"matcher/matcher.inInclusiveRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan or equal to <a>matcher/matcher.inInclusiveRange.low</a> and less than or equal to <a>matcher/matcher.inInclusiveRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inOpenClosedRange":{"name":"inOpenClosedRange","qualifiedName":"matcher/matcher.inOpenClosedRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan <a>matcher/matcher.inOpenClosedRange.low</a> and less than or equal to <a>matcher/matcher.inOpenClosedRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isIn":{"name":"isIn","qualifiedName":"matcher/matcher.isIn","comment":"<p>Returns a matcher that matches if the match argument is in\nthe expected value. This is the converse of <a>matcher/matcher.contains</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isNot":{"name":"isNot","qualifiedName":"matcher/matcher.isNot","comment":"<p>This returns a matcher that inverts <a>matcher/matcher.isNot.matcher</a> to its logical negation.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"lessThan":{"name":"lessThan","qualifiedName":"matcher/matcher.lessThan","comment":"<p>Returns a matcher which matches if the match argument is less\nthan the given <a>matcher/matcher.lessThan.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"lessThanOrEqualTo":{"name":"lessThanOrEqualTo","qualifiedName":"matcher/matcher.lessThanOrEqualTo","comment":"<p>Returns a matcher which matches if the match argument is less\nthan or equal to the given <a>matcher/matcher.lessThanOrEqualTo.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"matches":{"name":"matches","qualifiedName":"matcher/matcher.matches","comment":"<p>Returns a matcher that matches if the match argument is a string and\nmatches the regular expression given by <a>matcher/matcher.matches.re</a>. <a>matcher/matcher.matches.re</a> can be a RegExp\ninstance or a string; in the latter case it will be used to create\na RegExp instance.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"re":{"name":"re","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"orderedEquals":{"name":"orderedEquals","qualifiedName":"matcher/matcher.orderedEquals","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s that have the same\nlength and the same elements as <a>matcher/matcher.orderedEquals.expected</a>, and in the same order.\nThis is equivalent to equals but does not recurse.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"pairwiseCompare":{"name":"pairwiseCompare","qualifiedName":"matcher/matcher.pairwiseCompare","comment":"<p>A pairwise matcher for iterable. You can pass an arbitrary <a>matcher/matcher.pairwiseCompare.comparator</a>\nfunction that takes an expected and actual argument which will be applied\nto each pair in order. <a>matcher/matcher.pairwiseCompare.description</a>  should be a meaningful name for\nthe comparator.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":null,"annotations":[]},"comparator":{"name":"comparator","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"predicate":{"name":"predicate","qualifiedName":"matcher/matcher.predicate","comment":"<p>Returns a matcher that uses an arbitrary function that returns\ntrue or false for the actual value. For example:</p>\n<pre><code>expect(v, predicate((x) =&gt; ((x % 2) == 0), \"is even\"))\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"description":{"name":"description","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"\"satisfies function\"","annotations":[]}},"annotations":[]},"same":{"name":"same","qualifiedName":"matcher/matcher.same","comment":"<p>Returns a matches that matches if the value is the same instance\nas <a>matcher/matcher.same.expected</a>, using <a>dart-core.identical</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"startsWith":{"name":"startsWith","qualifiedName":"matcher/matcher.startsWith","comment":"<p>Returns a matcher that matches if the match argument is a string and\nstarts with <a>matcher/matcher.startsWith.prefixString</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"prefixString":{"name":"prefixString","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"stringContainsInOrder":{"name":"stringContainsInOrder","qualifiedName":"matcher/matcher.stringContainsInOrder","comment":"<p>Returns a matcher that matches if the match argument is a string and\ncontains a given list of <a>matcher/matcher.stringContainsInOrder.substrings</a> in relative order.</p>\n<p>For example, <code>stringContainsInOrder([\"a\", \"e\", \"i\", \"o\", \"u\"])</code> will match\n\"abcdefghijklmnopqrstuvwxyz\".</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"substrings":{"name":"substrings","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"throwsA":{"name":"throwsA","qualifiedName":"matcher/matcher.throwsA","comment":"<p>This can be used to match two kinds of objects:</p><ul><li>\n<p>A <a>dart-core.Function</a> that throws an exception when called. The function cannot\ntake any arguments. If you want to test that a function expecting\narguments throws, wrap it in another zero-argument function that calls\nthe one you want to test.</p></li><li>\n<p>A <a>matcher/dart-async.Future</a> that completes with an exception. Note that this creates an\nasynchronous expectation. The call to <code>expect()</code> that includes this will\nreturn immediately and execution will continue. Later, when the future\ncompletes, the actual expectation will run.</p></li></ul>\n<p>In both cases, when an exception is thrown, this will test that the exception\nobject matches <a>matcher/matcher.throwsA.matcher</a>. If <a>matcher/matcher.throwsA.matcher</a> is not an instance of <a>matcher/matcher.Matcher</a>, it\nwill implicitly be treated as <code>equals(matcher)</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"unorderedEquals":{"name":"unorderedEquals","qualifiedName":"matcher/matcher.unorderedEquals","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s that have the same\nlength and the same elements as <a>matcher/matcher.unorderedEquals.expected</a>, but not necessarily in\nthe same order. Note that this is O(n^2) so should only be used on\nsmall objects.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"unorderedMatches":{"name":"unorderedMatches","qualifiedName":"matcher/matcher.unorderedMatches","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s whose elements match the matchers\nin <a>matcher/matcher.unorderedMatches.expected</a>, but not necessarily in the same order.</p>\n<p> Note that this is <code>O(n^2)</code> and so should only be used on small objects.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"wrapMatcher":{"name":"wrapMatcher","qualifiedName":"matcher/matcher.wrapMatcher","comment":"<p>Takes an argument and returns an equivalent matcher.\nIf the argument is already a matcher this does nothing,\nelse if the argument is a function, it generates a predicate\nfunction matcher, else it generates an equals matcher.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"matcher/matcher.Matcher","inner":[]}],"parameters":{"x":{"name":"x","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"CustomMatcher","qualifiedName":"matcher/matcher.CustomMatcher","preview":"<p>A useful utility class for implementing other matchers through inheritance.\nDerived classes should call the base constructor with a feature name and\ndescription, and an instance matcher, and should implement the\n<a>matcher/matcher.CustomMatcher.featureValueOf</a> abstract method.</p>"},{"name":"DefaultFailureHandler","qualifiedName":"matcher/matcher.DefaultFailureHandler"},{"name":"Description","qualifiedName":"matcher/matcher.Description","preview":"<p>Matchers build up their error messages by appending to\nDescription objects. This interface is implemented by\nStringDescription. This interface is unlikely to need\nother implementations, but could be useful to replace in\nsome cases - e.g. language conversion.</p>"},{"name":"FailureHandler","qualifiedName":"matcher/matcher.FailureHandler","preview":"<p>Failed matches are reported using a default IFailureHandler.\nThe default implementation simply throws <a>matcher/matcher.TestFailure</a>s;\nthis can be replaced by some other implementation of\nIFailureHandler by calling configureExpectHandler.</p>"},{"name":"Matcher","qualifiedName":"matcher/matcher.Matcher","preview":"<p><a>matcher/matcher.expect</a> Matchers must implement/extend the Matcher class.\nThe base Matcher class has a generic implementation of <a>matcher/matcher.Matcher.describeMismatch</a>\nso this does not need to be provided unless a more clear description is\nrequired. The other two methods (<a>matcher/matcher.Matcher.matches</a> and <a>matcher/matcher.Matcher.describe</a>)\nmust always be provided as they are highly matcher-specific.</p>"},{"name":"StringDescription","qualifiedName":"matcher/matcher.StringDescription","preview":"<p>The default implementation of IDescription. This should rarely need\nsubstitution, although conceivably it is a place where other languages\ncould be supported.</p>"},{"name":"Throws","qualifiedName":"matcher/matcher.Throws"},{"name":"TypeMatcher","qualifiedName":"matcher/matcher.TypeMatcher"},{"name":"isInstanceOf","qualifiedName":"matcher/matcher.isInstanceOf","preview":"<p>Returns a matcher that matches if an object is an instance\nof type (or a subtype).</p>"}],"typedef":{"ErrorFormatter":{"name":"ErrorFormatter","qualifiedName":"matcher/matcher.ErrorFormatter","comment":"<p>The ErrorFormatter type is used for functions that\ncan be used to build up error reports upon <a>matcher/matcher.expect</a> failures.\nThere is one built-in implementation (defaultErrorFormatter)\nwhich is used by the default failure handler. If the failure handler\nis replaced it may be desirable to replace the stringDescription\nerror formatter with another.</p>","return":"dart-core.String","parameters":{"actual":{"name":"actual","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"matcher/matcher.Matcher","inner":[]}],"value":null,"annotations":[]},"reason":{"name":"reason","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"matchState":{"name":"matchState","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]},"verbose":{"name":"verbose","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.bool","inner":[]}],"value":null,"annotations":[]}},"annotations":[],"generics":{},"preview":"<p>The ErrorFormatter type is used for functions that\ncan be used to build up error reports upon <a>matcher/matcher.expect</a> failures.\nThere is one built-in implementation (defaultErrorFormatter)\nwhich is used by the default failure handler. If the failure handler\nis replaced it may be desirable to replace the stringDescription\nerror formatter with another.</p>"}},"error":[{"name":"TestFailure","qualifiedName":"matcher/matcher.TestFailure","preview":"<p>The objects thrown by the default failure handler.</p>"}]},"packageName":"matcher","packageIntro":""}