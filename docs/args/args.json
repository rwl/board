{"name":"args","qualifiedName":"args/args","comment":"<p>Parser support for transforming raw command-line arguments into a set\nof options and values.</p>\n<p>This library supports <a href=\"http://www.gnu.org/prep/standards/standards.html#Command_002dLine-Interfaces\">GNU</a> and <a href=\"http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap12.html#tag_12_02\">POSIX</a> style options, and it works\nin both server-side and client-side apps.</p>\n<p>For information on installing this library, see the\n<a href=\"http://pub.dartlang.org/packages/args\">args package on pub.dartlang.org</a>.\nHere's an example of importing this library:</p>\n<pre><code>import 'package:args/args.dart';\n</code></pre>\n<h2>Defining options</h2>\n<p>To use this library, first create an <a>args/args.ArgParser</a>:</p>\n<pre><code>var parser = new ArgParser();\n</code></pre>\n<p>Then define a set of options on that parser using addOption() and\naddFlag(). Here's the minimal way to create an option named \"name\":</p>\n<pre><code>parser.addOption('name');\n</code></pre>\n<p>When an option can only be set or unset (as opposed to taking a string\nvalue), use a flag:</p>\n<pre><code>parser.addFlag('name');\n</code></pre>\n<p>Flag options, by default, accept a 'no-' prefix to negate the option.\nYou can disable the 'no-' prefix using the <code>negatable</code> parameter:</p>\n<pre><code>parser.addFlag('name', negatable: false);\n</code></pre>\n<p><strong>Terminology note:</strong>\nFrom here on out, the term <em>option</em> refers to both regular options and\nflags. In cases where the distinction matters, this documentation uses\nthe term <em>non-flag option.</em></p>\n<p>Options can have an optional single-character abbreviation, specified\nwith the <code>abbr</code> parameter:</p>\n<pre><code>parser.addOption('mode', abbr: 'm');\nparser.addFlag('verbose', abbr: 'v');\n</code></pre>\n<p>Options can also have a default value, specified with the <code>defaultsTo</code>\nparameter. The default value is used when arguments don't specify the\noption.</p>\n<pre><code>parser.addOption('mode', defaultsTo: 'debug');\nparser.addFlag('verbose', defaultsTo: false);\n</code></pre>\n<p>The default value for non-flag options can be any <a>dart-core.String</a>. For flags,\nit must be a <a>dart-core.bool</a>.</p>\n<p>To validate a non-flag option, you can use the <code>allowed</code> parameter to\nprovide an allowed set of values. When you do, the parser throws a\n<a>dart-core.FormatException</a> if the value for an option is not in the allowed set.\nHere's an example of specifying allowed values:</p>\n<pre><code>parser.addOption('mode', allowed: ['debug', 'release']);\n</code></pre>\n<p>You can use the <code>callback</code> parameter to associate a function with an\noption. Later, when parsing occurs, the callback function is invoked\nwith the value of the option:</p>\n<pre><code>parser.addOption('mode', callback: (mode) =&gt; print('Got mode $mode));\nparser.addFlag('verbose', callback: (verbose) {\n  if (verbose) print('Verbose');\n});\n</code></pre>\n<p>The callbacks for all options are called whenever a set of arguments\nis parsed. If an option isn't provided in the args, its callback is\npassed the default value, or <code>null</code> if no default value is set.</p>\n<h2>Parsing arguments</h2>\n<p>Once you have an <a>args/args.ArgParser</a> set up with some options and flags, you\nuse it by calling ArgParser.parse() with a set of arguments:</p>\n<pre><code>var results = parser.parse(['some', 'command', 'line', 'args']);\n</code></pre>\n<p>These arguments usually come from the arguments to main\n(<code>main(List&lt;String&gt; arguments</code>), but you can pass in any list of strings.\nThe parse() method returns an instance of <a>args/args.ArgResults</a>, a map-like\nobject that contains the values of the parsed options.</p>\n<pre><code>var parser = new ArgParser();\nparser.addOption('mode');\nparser.addFlag('verbose', defaultsTo: true);\nvar results = parser.parse(['--mode', 'debug', 'something', 'else']);\n\nprint(results['mode']); // debug\nprint(results['verbose']); // true\n</code></pre>\n<p>By default, the parse() method stops as soon as it reaches <code>--</code> by itself\nor anything that the parser doesn't recognize as an option, flag, or\noption value. If arguments still remain, they go into <a>args/args.ArgResults.rest</a>.</p>\n<pre><code>print(results.rest); // ['something', 'else']\n</code></pre>\n<p>To continue to parse options found after non-option arguments, call\nparse() with <code>allowTrailingOptions: true</code>.</p>\n<h2>Specifying options</h2>\n<p>To actually pass in options and flags on the command line, use GNU or\nPOSIX style. Consider this option:</p>\n<pre><code>parser.addOption('name', abbr: 'n');\n</code></pre>\n<p>You can specify its value on the command line using any of the following:</p>\n<pre><code>--name=somevalue\n--name somevalue\n-nsomevalue\n-n somevalue\n</code></pre>\n<p>Consider this flag:</p>\n<pre><code>parser.addFlag('name', abbr: 'n');\n</code></pre>\n<p>You can set it to true using one of the following:</p>\n<pre><code>--name\n-n\n</code></pre>\n<p>You can set it to false using the following:</p>\n<pre><code>--no-name\n</code></pre>\n<p>Multiple flag abbreviations can be collapsed into a single argument. Say\nyou define these flags:</p>\n<pre><code>parser.addFlag('verbose', abbr: 'v');\nparser.addFlag('french', abbr: 'f');\nparser.addFlag('iambic-pentameter', abbr: 'i');\n</code></pre>\n<p>You can set all three flags at once:</p>\n<pre><code>-vfi\n</code></pre>\n<p>By default, an option has only a single value, with later option values\noverriding earlier ones; for example:</p>\n<pre><code>var parser = new ArgParser();\nparser.addOption('mode');\nvar results = parser.parse(['--mode', 'on', '--mode', 'off']);\nprint(results['mode']); // prints 'off'\n</code></pre>\n<p>If you need multiple values, set the <code>allowMultiple</code> parameter. In that\ncase the option can occur multiple times, and the parse() method returns\na list of values:</p>\n<pre><code>var parser = new ArgParser();\nparser.addOption('mode', allowMultiple: true);\nvar results = parser.parse(['--mode', 'on', '--mode', 'off']);\nprint(results['mode']); // prints '[on, off]'\n</code></pre>\n<h2>Defining commands</h2>\n<p>In addition to <em>options</em>, you can also define <em>commands</em>. A command is\na named argument that has its own set of options. For example, consider\nthis shell command:</p>\n<pre><code>$ git commit -a\n</code></pre>\n<p>The executable is <code>git</code>, the command is <code>commit</code>, and the <code>-a</code> option is\nan option passed to the command. You can add a command using the\naddCommand method:</p>\n<pre><code>var parser = new ArgParser();\nvar command = parser.addCommand('commit');\n</code></pre>\n<p>The addCommand() method returns another <a>args/args.ArgParser</a>, which you can then\nuse to define options specific to that command. If you already have an\n<a>args/args.ArgParser</a> for the command's options, you can pass it to addCommand:</p>\n<pre><code>var parser = new ArgParser();\nvar command = new ArgParser();\nparser.addCommand('commit', command);\n</code></pre>\n<p>The <a>args/args.ArgParser</a> for a command can then define options or flags:</p>\n<pre><code>command.addFlag('all', abbr: 'a');\n</code></pre>\n<p>You can add multiple commands to the same parser so that a user can select\none from a range of possible commands. When parsing an argument list,\nyou can then determine which command was entered and what options were\nprovided for it.</p>\n<pre><code>var results = parser.parse(['commit', '-a']);\nprint(results.command.name);   // \"commit\"\nprint(results.command['all']); // true\n</code></pre>\n<p>Options for a command must appear after the command in the argument list.\nFor example, given the above parser, \"git -a commit\" is <em>not</em> valid. The\nparser tries to find the right-most command that accepts an option. For\nexample:</p>\n<pre><code>var parser = new ArgParser();\nparser.addFlag('all', abbr: 'a');\nvar command = parser.addCommand('commit');\ncommand.addFlag('all', abbr: 'a');\n\nvar results = parser.parse(['commit', '-a']);\nprint(results.command['all']); // true\n</code></pre>\n<p>Here, both the top-level parser and the \"commit\" command can accept a\n\"-a\" (which is probably a bad command line interface, admittedly). In\nthat case, when \"-a\" appears after \"commit\", it is applied to that\ncommand. If it appears to the left of \"commit\", it is given to the\ntop-level parser.</p>\n<h2>Displaying usage</h2>\n<p>You can automatically generate nice help text, suitable for use as the\noutput of <code>--help</code>. To display good usage information, you should\nprovide some help text when you create your options.</p>\n<p>To define help text for an entire option, use the <code>help</code> parameter:</p>\n<pre><code>parser.addOption('mode', help: 'The compiler configuration',\n    allowed: ['debug', 'release']);\nparser.addFlag('verbose', help: 'Show additional diagnostic info');\n</code></pre>\n<p>For non-flag options, you can also provide detailed help for each expected\nvalue by using the <code>allowedHelp</code> parameter:</p>\n<pre><code>parser.addOption('arch', help: 'The architecture to compile for',\n    allowedHelp: {\n      'ia32': 'Intel x86',\n      'arm': 'ARM Holding 32-bit chip'\n    });\n</code></pre>\n<p>To display the help, use the ArgParser getUsage() method:</p>\n<pre><code>print(parser.getUsage());\n</code></pre>\n<p>The resulting string looks something like this:</p>\n<pre><code>--mode            The compiler configuration\n                  [debug, release]\n\n--[no-]verbose    Show additional diagnostic info\n--arch            The architecture to compile for\n\n      [arm]       ARM Holding 32-bit chip\n      [ia32]      Intel x86\n</code></pre>\n<p>To assist the formatting of the usage help, single-line help text is\nfollowed by a single new line. Options with multi-line help text are\nfollowed by two new lines. This provides spatial diversity between options.</p>","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{}},"classes":{"class":[{"name":"ArgParser","qualifiedName":"args/args.ArgParser","preview":"<p>A class for taking a list of raw command line arguments and parsing out\noptions and flags from them.</p>"},{"name":"ArgResults","qualifiedName":"args/args.ArgResults","preview":"<p>The results of parsing a series of command line arguments using\nArgParser.parse(). Includes the parsed options and any remaining unparsed\ncommand line arguments.</p>"},{"name":"Option","qualifiedName":"args/args.Option","preview":"<p>A command-line option. Includes both flags and options which take a value.</p>"}],"typedef":{},"error":[]},"packageName":"args","packageIntro":""}