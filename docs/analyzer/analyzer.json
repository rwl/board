{"name":"analyzer","qualifiedName":"analyzer/analyzer","comment":"","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"parseCompilationUnit":{"name":"parseCompilationUnit","qualifiedName":"analyzer/analyzer.parseCompilationUnit","comment":"<p>Parses a string of Dart code into an AST.</p>\n<p>If <a>analyzer/analyzer.parseCompilationUnit.name</a> is passed, it's used in error messages as the name of the code\nbeing parsed.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/analyzer.CompilationUnit","inner":[]}],"parameters":{"contents":{"name":"contents","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"name":{"name":"name","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"suppressErrors":{"name":"suppressErrors","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"parseDartFile":{"name":"parseDartFile","qualifiedName":"analyzer/analyzer.parseDartFile","comment":"<p>Parses a Dart file into an AST.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/analyzer.CompilationUnit","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"stringLiteralToString":{"name":"stringLiteralToString","qualifiedName":"analyzer/analyzer.stringLiteralToString","comment":"<p>Converts an AST node representing a string literal into a <a>dart-core.String</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"literal":{"name":"literal","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.StringLiteral","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"AdjacentStrings","qualifiedName":"analyzer/analyzer.AdjacentStrings","preview":"<p>Instances of the class <code>AdjacentStrings</code> represents two or more string literals that are\nimplicitly concatenated because of being adjacent (separated only by whitespace).</p>"},{"name":"AnalysisError","qualifiedName":"analyzer/analyzer.AnalysisError","preview":"<p>Instances of the class <code>AnalysisError</code> represent an error discovered during the analysis of\nsome Dart code.</p>"},{"name":"AnalysisErrorListener","qualifiedName":"analyzer/analyzer.AnalysisErrorListener","preview":"<p>The interface <code>AnalysisErrorListener</code> defines the behavior of objects that listen for\n<a>analyzer/analyzer.AnalysisError</a> being produced by the analysis engine.</p>"},{"name":"AnalysisErrorListener_NULL_LISTENER","qualifiedName":"analyzer/analyzer.AnalysisErrorListener_NULL_LISTENER"},{"name":"AnalysisErrorWithProperties","qualifiedName":"analyzer/analyzer.AnalysisErrorWithProperties","preview":"<p>Instances of the class <code>AnalysisErrorWithProperties</code></p>"},{"name":"AngularCode","qualifiedName":"analyzer/analyzer.AngularCode","preview":"<p>The enumeration <code>AngularCode</code> defines Angular specific problems.</p>"},{"name":"AnnotatedNode","qualifiedName":"analyzer/analyzer.AnnotatedNode","preview":"<p>The abstract class <code>AnnotatedNode</code> defines the behavior of nodes that can be annotated with\nboth a comment and metadata.</p>"},{"name":"Annotation","qualifiedName":"analyzer/analyzer.Annotation","preview":"<p>Instances of the class <code>Annotation</code> represent an annotation that can be associated with an\nAST node.</p>"},{"name":"ArgumentDefinitionTest","qualifiedName":"analyzer/analyzer.ArgumentDefinitionTest","preview":"<p>Instances of the class <code>ArgumentDefinitionTest</code> represent an argument definition test.</p>"},{"name":"ArgumentList","qualifiedName":"analyzer/analyzer.ArgumentList","preview":"<p>Instances of the class <code>ArgumentList</code> represent a list of arguments in the invocation of a\nexecutable element: a function, method, or constructor.</p>"},{"name":"AsExpression","qualifiedName":"analyzer/analyzer.AsExpression","preview":"<p>Instances of the class <code>AsExpression</code> represent an 'as' expression.</p>"},{"name":"AssertStatement","qualifiedName":"analyzer/analyzer.AssertStatement","preview":"<p>Instances of the class <code>AssertStatement</code> represent an assert statement.</p>"},{"name":"AssignmentExpression","qualifiedName":"analyzer/analyzer.AssignmentExpression","preview":"<p>Instances of the class <code>AssignmentExpression</code> represent an assignment expression.</p>"},{"name":"AstCloner","qualifiedName":"analyzer/analyzer.AstCloner","preview":"<p>Instances of the class <code>AstCloner</code> implement an object that will clone any AST structure\nthat it visits. The cloner will only clone the structure, it will not preserve any resolution\nresults or properties associated with the nodes.</p>"},{"name":"AstComparator","qualifiedName":"analyzer/analyzer.AstComparator","preview":"<p>Instances of the class <code>AstComparator</code> compare the structure of two ASTNodes to see whether\nthey are equal.</p>"},{"name":"AstNode","qualifiedName":"analyzer/analyzer.AstNode","preview":"<p>The abstract class <code>AstNode</code> defines the behavior common to all nodes in the AST structure\nfor a Dart program.</p>"},{"name":"AstVisitor","qualifiedName":"analyzer/analyzer.AstVisitor","preview":"<p>The interface <code>AstVisitor</code> defines the behavior of objects that can be used to visit an AST\nstructure.</p>"},{"name":"BinaryExpression","qualifiedName":"analyzer/analyzer.BinaryExpression","preview":"<p>Instances of the class <code>BinaryExpression</code> represent a binary (infix) expression.</p>"},{"name":"Block","qualifiedName":"analyzer/analyzer.Block","preview":"<p>Instances of the class <code>Block</code> represent a sequence of statements.</p>"},{"name":"BlockFunctionBody","qualifiedName":"analyzer/analyzer.BlockFunctionBody","preview":"<p>Instances of the class <code>BlockFunctionBody</code> represent a function body that consists of a\nblock of statements.</p>"},{"name":"BooleanErrorListener","qualifiedName":"analyzer/analyzer.BooleanErrorListener","preview":"<p>Instances of the class <code>BooleanErrorListener</code> implement a listener that keeps track of\nwhether an error has been reported to it.</p>"},{"name":"BooleanLiteral","qualifiedName":"analyzer/analyzer.BooleanLiteral","preview":"<p>Instances of the class <code>BooleanLiteral</code> represent a boolean literal expression.</p>"},{"name":"BreadthFirstVisitor","qualifiedName":"analyzer/analyzer.BreadthFirstVisitor","preview":"<p>Instances of the class <code>BreadthFirstVisitor</code> implement an AST visitor that will recursively\nvisit all of the nodes in an AST structure, similar to <a>analyzer/analyzer.GeneralizingAstVisitor</a>. This\nvisitor uses a breadth-first ordering rather than the depth-first ordering of\n<a>analyzer/analyzer.GeneralizingAstVisitor</a>.</p>"},{"name":"BreakStatement","qualifiedName":"analyzer/analyzer.BreakStatement","preview":"<p>Instances of the class <code>BreakStatement</code> represent a break statement.</p>"},{"name":"CascadeExpression","qualifiedName":"analyzer/analyzer.CascadeExpression","preview":"<p>Instances of the class <code>CascadeExpression</code> represent a sequence of cascaded expressions:\nexpressions that share a common target. There are three kinds of expressions that can be used in\na cascade expression: <a>analyzer/analyzer.IndexExpression</a>, <a>analyzer/analyzer.MethodInvocation</a> and\n<a>analyzer/analyzer.PropertyAccess</a>.</p>"},{"name":"CatchClause","qualifiedName":"analyzer/analyzer.CatchClause","preview":"<p>Instances of the class <code>CatchClause</code> represent a catch clause within a try statement.</p>"},{"name":"ClassDeclaration","qualifiedName":"analyzer/analyzer.ClassDeclaration","preview":"<p>Instances of the class <code>ClassDeclaration</code> represent the declaration of a class.</p>"},{"name":"ClassMember","qualifiedName":"analyzer/analyzer.ClassMember","preview":"<p>The abstract class <code>ClassMember</code> defines the behavior common to nodes that declare a name\nwithin the scope of a class.</p>"},{"name":"ClassTypeAlias","qualifiedName":"analyzer/analyzer.ClassTypeAlias","preview":"<p>Instances of the class <code>ClassTypeAlias</code> represent a class type alias.</p>"},{"name":"Combinator","qualifiedName":"analyzer/analyzer.Combinator","preview":"<p>Instances of the class <code>Combinator</code> represent the combinator associated with an import\ndirective.</p>"},{"name":"Comment","qualifiedName":"analyzer/analyzer.Comment","preview":"<p>Instances of the class <code>Comment</code> represent a comment within the source code.</p>"},{"name":"CommentReference","qualifiedName":"analyzer/analyzer.CommentReference","preview":"<p>Instances of the class <code>CommentReference</code> represent a reference to a Dart element that is\nfound within a documentation comment.</p>"},{"name":"CommentType","qualifiedName":"analyzer/analyzer.CommentType","preview":"<p>The enumeration <code>CommentType</code> encodes all the different types of comments that are\nrecognized by the parser.</p>"},{"name":"CompilationUnit","qualifiedName":"analyzer/analyzer.CompilationUnit","preview":"<p>Instances of the class <code>CompilationUnit</code> represent a compilation unit.</p>"},{"name":"CompilationUnitMember","qualifiedName":"analyzer/analyzer.CompilationUnitMember","preview":"<p>Instances of the class <code>CompilationUnitMember</code> defines the behavior common to nodes that\ndeclare a name within the scope of a compilation unit.</p>"},{"name":"CompileTimeErrorCode","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode","preview":"<p>The enumeration <code>CompileTimeErrorCode</code> defines the error codes used for compile time\nerrors. The convention for this class is for the name of the error code to indicate the problem\nthat caused the error to be generated and for the error message to explain what is wrong and,\nwhen appropriate, how the problem can be corrected.</p>"},{"name":"ConditionalExpression","qualifiedName":"analyzer/analyzer.ConditionalExpression","preview":"<p>Instances of the class <code>ConditionalExpression</code> represent a conditional expression.</p>"},{"name":"ConstantEvaluator","qualifiedName":"analyzer/analyzer.ConstantEvaluator","preview":"<p>Instances of the class <code>ConstantEvaluator</code> evaluate constant expressions to produce their\ncompile-time value. According to the Dart Language Specification: &lt;blockquote> A constant\nexpression is one of the following:\n<em> A literal number.\n</em> A literal boolean.\n<em> A literal string where any interpolated expression is a compile-time constant that evaluates\nto a numeric, string or boolean value or to <code>null</code>.\n</em> <code>null</code>.\n<em> A reference to a static constant variable.\n</em> An identifier expression that denotes a constant variable, a class or a type parameter.\n<em> A constant constructor invocation.\n</em> A constant list literal.\n<em> A constant map literal.\n</em> A simple or qualified identifier denoting a top-level function or a static method.\n<em> A parenthesized expression <code>(e)</code> where <code>e</code> is a constant expression.\n</em> An expression of one of the forms <code>identical(e1, e2)</code>, <code>e1 == e2</code>,\n<code>e1 != e2</code> where <code>e1</code> and <code>e2</code> are constant expressions that evaluate to a\nnumeric, string or boolean value or to <code>null</code>.\n<em> An expression of one of the forms <code>!e</code>, <code>e1 &amp;&amp; e2</code> or <code>e1 || e2</code>, where\n<code>e</code>, <code>e1</code> and <code>e2</code> are constant expressions that evaluate to a boolean value or\nto <code>null</code>.\n</em> An expression of one of the forms <code>~e</code>, <code>e1 ^ e2</code>, <code>e1 &amp; e2</code>,\n<code>e1 | e2</code>, <code>e1 &gt;&gt; e2</code> or <code>e1 &lt;&lt; e2</code>, where <code>e</code>, <code>e1</code> and <code>e2</code>\nare constant expressions that evaluate to an integer value or to <code>null</code>.\n* An expression of one of the forms <code>-e</code>, <code>e1 + e2</code>, <code>e1 - e2</code>,\n<code>e1 * e2</code>, <code>e1 / e2</code>, <code>e1 ~/ e2</code>, <code>e1 &gt; e2</code>, <code>e1 &lt; e2</code>,\n<code>e1 &gt;= e2</code>, <code>e1 &lt;= e2</code> or <code>e1 % e2</code>, where <code>e</code>, <code>e1</code> and <code>e2</code>\nare constant expressions that evaluate to a numeric value or to <code>null</code>.\n&lt;/blockquote> The values returned by instances of this class are therefore <code>null</code> and\ninstances of the classes <code>Boolean</code>, <code>BigInteger</code>, <code>Double</code>, <code>String</code>, and\n<code>DartObject</code>.</p>"},{"name":"ConstructorDeclaration","qualifiedName":"analyzer/analyzer.ConstructorDeclaration","preview":"<p>Instances of the class <code>ConstructorDeclaration</code> represent a constructor declaration.</p>"},{"name":"ConstructorFieldInitializer","qualifiedName":"analyzer/analyzer.ConstructorFieldInitializer","preview":"<p>Instances of the class <code>ConstructorFieldInitializer</code> represent the initialization of a\nfield within a constructor's initialization list.</p>"},{"name":"ConstructorInitializer","qualifiedName":"analyzer/analyzer.ConstructorInitializer","preview":"<p>Instances of the class <code>ConstructorInitializer</code> defines the behavior of nodes that can\noccur in the initializer list of a constructor declaration.</p>"},{"name":"ConstructorName","qualifiedName":"analyzer/analyzer.ConstructorName","preview":"<p>Instances of the class <code>ConstructorName</code> represent the name of the constructor.</p>"},{"name":"ContinueStatement","qualifiedName":"analyzer/analyzer.ContinueStatement","preview":"<p>Instances of the class <code>ContinueStatement</code> represent a continue statement.</p>"},{"name":"Declaration","qualifiedName":"analyzer/analyzer.Declaration","preview":"<p>The abstract class <code>Declaration</code> defines the behavior common to nodes that represent the\ndeclaration of a name. Each declared name is visible within a name scope.</p>"},{"name":"DeclaredIdentifier","qualifiedName":"analyzer/analyzer.DeclaredIdentifier","preview":"<p>Instances of the class <code>DeclaredIdentifier</code> represent the declaration of a single\nidentifier.</p>"},{"name":"DefaultFormalParameter","qualifiedName":"analyzer/analyzer.DefaultFormalParameter","preview":"<p>Instances of the class <code>DefaultFormalParameter</code> represent a formal parameter with a default\nvalue. There are two kinds of parameters that are both represented by this class: named formal\nparameters and positional formal parameters.</p>"},{"name":"Directive","qualifiedName":"analyzer/analyzer.Directive","preview":"<p>The abstract class <code>Directive</code> defines the behavior common to nodes that represent a\ndirective.</p>"},{"name":"DoStatement","qualifiedName":"analyzer/analyzer.DoStatement","preview":"<p>Instances of the class <code>DoStatement</code> represent a do statement.</p>"},{"name":"DoubleLiteral","qualifiedName":"analyzer/analyzer.DoubleLiteral","preview":"<p>Instances of the class <code>DoubleLiteral</code> represent a floating point literal expression.</p>"},{"name":"ElementLocator","qualifiedName":"analyzer/analyzer.ElementLocator","preview":"<p>Instances of the class <code>ElementLocator</code> locate the <a>analyzer/engine-element.Element</a>\nassociated with a given <a>analyzer/analyzer.AstNode</a>.</p>"},{"name":"ElementLocator_ElementMapper","qualifiedName":"analyzer/analyzer.ElementLocator_ElementMapper","preview":"<p>Visitor that maps nodes to elements.</p>"},{"name":"EmptyFunctionBody","qualifiedName":"analyzer/analyzer.EmptyFunctionBody","preview":"<p>Instances of the class <code>EmptyFunctionBody</code> represent an empty function body, which can only\nappear in constructors or abstract methods.</p>"},{"name":"EmptyStatement","qualifiedName":"analyzer/analyzer.EmptyStatement","preview":"<p>Instances of the class <code>EmptyStatement</code> represent an empty statement.</p>"},{"name":"EphemeralIdentifier","qualifiedName":"analyzer/analyzer.EphemeralIdentifier","preview":"<p>Ephemeral identifiers are created as needed to mimic the presence of an empty identifier.</p>"},{"name":"ErrorCode","qualifiedName":"analyzer/analyzer.ErrorCode","preview":"<p>The interface <code>ErrorCode</code> defines the behavior common to objects representing error codes\nassociated with <a>analyzer/analyzer.AnalysisError</a>.</p>"},{"name":"ErrorProperty","qualifiedName":"analyzer/analyzer.ErrorProperty","preview":"<p>The enumeration <code>ErrorProperty</code> defines the properties that can be associated with an\n<a>analyzer/analyzer.AnalysisError</a>.</p>"},{"name":"ErrorReporter","qualifiedName":"analyzer/analyzer.ErrorReporter","preview":"<p>Instances of the class <code>ErrorReporter</code> wrap an error listener with utility methods used to\ncreate the errors being reported.</p>"},{"name":"ErrorSeverity","qualifiedName":"analyzer/analyzer.ErrorSeverity","preview":"<p>Instances of the enumeration <code>ErrorSeverity</code> represent the severity of an <a>analyzer/analyzer.ErrorCode</a>\n.</p>"},{"name":"ErrorType","qualifiedName":"analyzer/analyzer.ErrorType","preview":"<p>Instances of the enumeration <code>ErrorType</code> represent the type of an <a>analyzer/analyzer.ErrorCode</a>.</p>"},{"name":"ExportDirective","qualifiedName":"analyzer/analyzer.ExportDirective","preview":"<p>Instances of the class <code>ExportDirective</code> represent an export directive.</p>"},{"name":"Expression","qualifiedName":"analyzer/analyzer.Expression","preview":"<p>Instances of the class <code>Expression</code> defines the behavior common to nodes that represent an\nexpression.</p>"},{"name":"ExpressionFunctionBody","qualifiedName":"analyzer/analyzer.ExpressionFunctionBody","preview":"<p>Instances of the class <code>ExpressionFunctionBody</code> represent a function body consisting of a\nsingle expression.</p>"},{"name":"ExpressionStatement","qualifiedName":"analyzer/analyzer.ExpressionStatement","preview":"<p>Instances of the class <code>ExpressionStatement</code> wrap an expression as a statement.</p>"},{"name":"ExtendsClause","qualifiedName":"analyzer/analyzer.ExtendsClause","preview":"<p>Instances of the class <code>ExtendsClause</code> represent the \"extends\" clause in a class\ndeclaration.</p>"},{"name":"FieldDeclaration","qualifiedName":"analyzer/analyzer.FieldDeclaration","preview":"<p>Instances of the class <code>FieldDeclaration</code> represent the declaration of one or more fields\nof the same type.</p>"},{"name":"FieldFormalParameter","qualifiedName":"analyzer/analyzer.FieldFormalParameter","preview":"<p>Instances of the class <code>FieldFormalParameter</code> represent a field formal parameter.</p>"},{"name":"ForEachStatement","qualifiedName":"analyzer/analyzer.ForEachStatement","preview":"<p>Instances of the class <code>ForEachStatement</code> represent a for-each statement.</p>"},{"name":"ForStatement","qualifiedName":"analyzer/analyzer.ForStatement","preview":"<p>Instances of the class <code>ForStatement</code> represent a for statement.</p>"},{"name":"FormalParameter","qualifiedName":"analyzer/analyzer.FormalParameter","preview":"<p>The abstract class <code>FormalParameter</code> defines the behavior of objects representing a\nparameter to a function.</p>"},{"name":"FormalParameterList","qualifiedName":"analyzer/analyzer.FormalParameterList","preview":"<p>Instances of the class <code>FormalParameterList</code> represent the formal parameter list of a\nmethod declaration, function declaration, or function type alias.</p>"},{"name":"FunctionBody","qualifiedName":"analyzer/analyzer.FunctionBody","preview":"<p>The abstract class <code>FunctionBody</code> defines the behavior common to objects representing the\nbody of a function or method.</p>"},{"name":"FunctionDeclaration","qualifiedName":"analyzer/analyzer.FunctionDeclaration","preview":"<p>Instances of the class <code>FunctionDeclaration</code> wrap a <a>analyzer/analyzer.FunctionExpression</a> as a top-level declaration.</p>"},{"name":"FunctionDeclarationStatement","qualifiedName":"analyzer/analyzer.FunctionDeclarationStatement","preview":"<p>Instances of the class <code>FunctionDeclarationStatement</code> wrap a FunctionDeclaration\n  as a statement.</p>"},{"name":"FunctionExpression","qualifiedName":"analyzer/analyzer.FunctionExpression","preview":"<p>Instances of the class <code>FunctionExpression</code> represent a function expression.</p>"},{"name":"FunctionExpressionInvocation","qualifiedName":"analyzer/analyzer.FunctionExpressionInvocation","preview":"<p>Instances of the class <code>FunctionExpressionInvocation</code> represent the invocation of a\nfunction resulting from evaluating an expression. Invocations of methods and other forms of\nfunctions are represented by <a>analyzer/analyzer.MethodInvocation</a> nodes. Invocations of\ngetters and setters are represented by either <a>analyzer/analyzer.PrefixedIdentifier</a> or\n<a>analyzer/analyzer.PropertyAccess</a> nodes.</p>"},{"name":"FunctionTypeAlias","qualifiedName":"analyzer/analyzer.FunctionTypeAlias","preview":"<p>Instances of the class <code>FunctionTypeAlias</code> represent a function type alias.</p>"},{"name":"FunctionTypedFormalParameter","qualifiedName":"analyzer/analyzer.FunctionTypedFormalParameter","preview":"<p>Instances of the class <code>FunctionTypedFormalParameter</code> represent a function-typed formal\nparameter.</p>"},{"name":"GeneralizingAstVisitor","qualifiedName":"analyzer/analyzer.GeneralizingAstVisitor","preview":"<p>Instances of the class <code>GeneralizingAstVisitor</code> implement an AST visitor that will\nrecursively visit all of the nodes in an AST structure (like instances of the class\n<a>analyzer/analyzer.RecursiveAstVisitor</a>). In addition, when a node of a specific type is visited not only\nwill the visit method for that specific type of node be invoked, but additional methods for the\nsuperclasses of that node will also be invoked. For example, using an instance of this class to\nvisit a <a>analyzer/analyzer.Block</a> will cause the method <a>analyzer/analyzer.GeneralizingAstVisitor.visitBlock</a> to be invoked but will\nalso cause the methods <a>analyzer/analyzer.GeneralizingAstVisitor.visitStatement</a> and <a>analyzer/analyzer.GeneralizingAstVisitor.visitNode</a> to be\nsubsequently invoked. This allows visitors to be written that visit all statements without\nneeding to override the visit method for each of the specific subclasses of <a>analyzer/analyzer.Statement</a>.</p>"},{"name":"GeneralizingAstVisitor_BreadthFirstVisitor","qualifiedName":"analyzer/analyzer.GeneralizingAstVisitor_BreadthFirstVisitor"},{"name":"HideCombinator","qualifiedName":"analyzer/analyzer.HideCombinator","preview":"<p>Instances of the class <code>HideCombinator</code> represent a combinator that restricts the names\nbeing imported to those that are not in a given list.</p>"},{"name":"HintCode","qualifiedName":"analyzer/analyzer.HintCode","preview":"<p>The enumeration <code>HintCode</code> defines the hints and coding recommendations for best practices\nwhich are not mentioned in the Dart Language Specification.</p>"},{"name":"HtmlWarningCode","qualifiedName":"analyzer/analyzer.HtmlWarningCode","preview":"<p>The enumeration <code>HtmlWarningCode</code> defines the error codes used for warnings in HTML files.\nThe convention for this class is for the name of the error code to indicate the problem that\ncaused the error to be generated and for the error message to explain what is wrong and, when\nappropriate, how the problem can be corrected.</p>"},{"name":"Identifier","qualifiedName":"analyzer/analyzer.Identifier","preview":"<p>The abstract class <code>Identifier</code> defines the behavior common to nodes that represent an\nidentifier.</p>"},{"name":"IfStatement","qualifiedName":"analyzer/analyzer.IfStatement","preview":"<p>Instances of the class <code>IfStatement</code> represent an if statement.</p>"},{"name":"ImplementsClause","qualifiedName":"analyzer/analyzer.ImplementsClause","preview":"<p>Instances of the class <code>ImplementsClause</code> represent the \"implements\" clause in an class\ndeclaration.</p>"},{"name":"ImportDirective","qualifiedName":"analyzer/analyzer.ImportDirective","preview":"<p>Instances of the class <code>ImportDirective</code> represent an import directive.</p>"},{"name":"IncrementalAstCloner","qualifiedName":"analyzer/analyzer.IncrementalAstCloner","preview":"<p>Instances of the class <code>IncrementalAstCloner</code> implement an object that will clone any AST\nstructure that it visits. The cloner will clone the structure, replacing the specified ASTNode\nwith a new ASTNode, mapping the old token stream to a new token stream, and preserving resolution\nresults.</p>"},{"name":"IndexExpression","qualifiedName":"analyzer/analyzer.IndexExpression","preview":"<p>Instances of the class <code>IndexExpression</code> represent an index expression.</p>"},{"name":"InstanceCreationExpression","qualifiedName":"analyzer/analyzer.InstanceCreationExpression","preview":"<p>Instances of the class <code>InstanceCreationExpression</code> represent an instance creation\nexpression.</p>"},{"name":"IntegerLiteral","qualifiedName":"analyzer/analyzer.IntegerLiteral","preview":"<p>Instances of the class <code>IntegerLiteral</code> represent an integer literal expression.</p>"},{"name":"InterpolationElement","qualifiedName":"analyzer/analyzer.InterpolationElement","preview":"<p>The abstract class <code>InterpolationElement</code> defines the behavior common to elements within a\n<a>analyzer/analyzer.StringInterpolation</a>.</p>"},{"name":"InterpolationExpression","qualifiedName":"analyzer/analyzer.InterpolationExpression","preview":"<p>Instances of the class <code>InterpolationExpression</code> represent an expression embedded in a\nstring interpolation.</p>"},{"name":"InterpolationString","qualifiedName":"analyzer/analyzer.InterpolationString","preview":"<p>Instances of the class <code>InterpolationString</code> represent a non-empty substring of an\ninterpolated string.</p>"},{"name":"IsExpression","qualifiedName":"analyzer/analyzer.IsExpression","preview":"<p>Instances of the class <code>IsExpression</code> represent an is expression.</p>"},{"name":"Label","qualifiedName":"analyzer/analyzer.Label","preview":"<p>Instances of the class <code>Label</code> represent a label.</p>"},{"name":"LabeledStatement","qualifiedName":"analyzer/analyzer.LabeledStatement","preview":"<p>Instances of the class <code>LabeledStatement</code> represent a statement that has a label associated\nwith them.</p>"},{"name":"LibraryDirective","qualifiedName":"analyzer/analyzer.LibraryDirective","preview":"<p>Instances of the class <code>LibraryDirective</code> represent a library directive.</p>"},{"name":"LibraryIdentifier","qualifiedName":"analyzer/analyzer.LibraryIdentifier","preview":"<p>Instances of the class <code>LibraryIdentifier</code> represent the identifier for a library.</p>"},{"name":"ListLiteral","qualifiedName":"analyzer/analyzer.ListLiteral","preview":"<p>Instances of the class <code>ListLiteral</code> represent a list literal.</p>"},{"name":"Literal","qualifiedName":"analyzer/analyzer.Literal","preview":"<p>The abstract class <code>Literal</code> defines the behavior common to nodes that represent a literal\nexpression.</p>"},{"name":"MapLiteral","qualifiedName":"analyzer/analyzer.MapLiteral","preview":"<p>Instances of the class <code>MapLiteral</code> represent a literal map.</p>"},{"name":"MapLiteralEntry","qualifiedName":"analyzer/analyzer.MapLiteralEntry","preview":"<p>Instances of the class <code>MapLiteralEntry</code> represent a single key/value pair in a map\nliteral.</p>"},{"name":"MethodDeclaration","qualifiedName":"analyzer/analyzer.MethodDeclaration","preview":"<p>Instances of the class <code>MethodDeclaration</code> represent a method declaration.</p>"},{"name":"MethodInvocation","qualifiedName":"analyzer/analyzer.MethodInvocation","preview":"<p>Instances of the class <code>MethodInvocation</code> represent the invocation of either a function or\na method. Invocations of functions resulting from evaluating an expression are represented by\n<a>analyzer/analyzer.FunctionExpressionInvocation</a> nodes. Invocations of getters\nand setters are represented by either <a>analyzer/analyzer.PrefixedIdentifier</a> or\n<a>analyzer/analyzer.PropertyAccess</a> nodes.</p>"},{"name":"NamedExpression","qualifiedName":"analyzer/analyzer.NamedExpression","preview":"<p>Instances of the class <code>NamedExpression</code> represent an expression that has a name associated\nwith it. They are used in method invocations when there are named parameters.</p>"},{"name":"NamespaceDirective","qualifiedName":"analyzer/analyzer.NamespaceDirective","preview":"<p>The abstract class <code>NamespaceDirective</code> defines the behavior common to nodes that represent\na directive that impacts the namespace of a library.</p>"},{"name":"NativeClause","qualifiedName":"analyzer/analyzer.NativeClause","preview":"<p>Instances of the class <code>NativeClause</code> represent the \"native\" clause in an class\ndeclaration.</p>"},{"name":"NativeFunctionBody","qualifiedName":"analyzer/analyzer.NativeFunctionBody","preview":"<p>Instances of the class <code>NativeFunctionBody</code> represent a function body that consists of a\nnative keyword followed by a string literal.</p>"},{"name":"NodeList","qualifiedName":"analyzer/analyzer.NodeList","preview":"<p>Instances of the class {@code NodeList} represent a list of AST nodes that have a common parent.</p>"},{"name":"NodeLocator","qualifiedName":"analyzer/analyzer.NodeLocator","preview":"<p>Instances of the class <code>NodeLocator</code> locate the <a>analyzer/analyzer.AstNode</a> associated with a\nsource range, given the AST structure built from the source. More specifically, they will return\nthe <a>analyzer/analyzer.AstNode</a> with the shortest length whose source range completely encompasses\nthe specified range.</p>"},{"name":"NormalFormalParameter","qualifiedName":"analyzer/analyzer.NormalFormalParameter","preview":"<p>The abstract class <code>NormalFormalParameter</code> defines the behavior common to formal parameters\nthat are required (are not optional).</p>"},{"name":"NullLiteral","qualifiedName":"analyzer/analyzer.NullLiteral","preview":"<p>Instances of the class <code>NullLiteral</code> represent a null literal expression.</p>"},{"name":"ParameterKind","qualifiedName":"analyzer/analyzer.ParameterKind","preview":"<p>The enumeration <code>ParameterKind</code> defines the different kinds of parameters. There are two\nbasic kinds of parameters: required and optional. Optional parameters are further divided into\ntwo kinds: positional optional and named optional.</p>"},{"name":"ParenthesizedExpression","qualifiedName":"analyzer/analyzer.ParenthesizedExpression","preview":"<p>Instances of the class <code>ParenthesizedExpression</code> represent a parenthesized expression.</p>"},{"name":"PartDirective","qualifiedName":"analyzer/analyzer.PartDirective","preview":"<p>Instances of the class <code>PartDirective</code> represent a part directive.</p>"},{"name":"PartOfDirective","qualifiedName":"analyzer/analyzer.PartOfDirective","preview":"<p>Instances of the class <code>PartOfDirective</code> represent a part-of directive.</p>"},{"name":"PolymerCode","qualifiedName":"analyzer/analyzer.PolymerCode","preview":"<p>The enumeration <code>PolymerCode</code> defines Polymer specific problems.</p>"},{"name":"PostfixExpression","qualifiedName":"analyzer/analyzer.PostfixExpression","preview":"<p>Instances of the class <code>PostfixExpression</code> represent a postfix unary expression.</p>"},{"name":"PrefixExpression","qualifiedName":"analyzer/analyzer.PrefixExpression","preview":"<p>Instances of the class <code>PrefixExpression</code> represent a prefix unary expression.</p>"},{"name":"PrefixedIdentifier","qualifiedName":"analyzer/analyzer.PrefixedIdentifier","preview":"<p>Instances of the class <code>PrefixedIdentifier</code> represent either an identifier that is prefixed\nor an access to an object property where the target of the property access is a simple\nidentifier.</p>"},{"name":"PropertyAccess","qualifiedName":"analyzer/analyzer.PropertyAccess","preview":"<p>Instances of the class <code>PropertyAccess</code> represent the access of a property of an object.</p>"},{"name":"PubSuggestionCode","qualifiedName":"analyzer/analyzer.PubSuggestionCode","preview":"<p>The enumeration <code>PubSuggestionCode</code> defines the suggestions used for reporting deviations\nfrom pub best practices. The convention for this class is for the name of the bad practice to\nindicate the problem that caused the suggestion to be generated and for the message to explain\nwhat is wrong and, when appropriate, how the situation can be corrected.</p>"},{"name":"RecursiveAstVisitor","qualifiedName":"analyzer/analyzer.RecursiveAstVisitor","preview":"<p>Instances of the class <code>RecursiveAstVisitor</code> implement an AST visitor that will recursively\nvisit all of the nodes in an AST structure. For example, using an instance of this class to visit\na <a>analyzer/analyzer.Block</a> will also cause all of the statements in the block to be visited.</p>"},{"name":"RedirectingConstructorInvocation","qualifiedName":"analyzer/analyzer.RedirectingConstructorInvocation","preview":"<p>Instances of the class <code>RedirectingConstructorInvocation</code> represent the invocation of a\nanother constructor in the same class from within a constructor's initialization list.</p>"},{"name":"RethrowExpression","qualifiedName":"analyzer/analyzer.RethrowExpression","preview":"<p>Instances of the class <code>RethrowExpression</code> represent a rethrow expression.</p>"},{"name":"ReturnStatement","qualifiedName":"analyzer/analyzer.ReturnStatement","preview":"<p>Instances of the class <code>ReturnStatement</code> represent a return statement.</p>"},{"name":"ScopedNameFinder","qualifiedName":"analyzer/analyzer.ScopedNameFinder","preview":"<p>Traverse the AST from initial child node to successive parents, building a collection of local\nvariable and parameter names visible to the initial child node. In case of name shadowing, the\nfirst name seen is the most specific one so names are not redefined.</p>"},{"name":"ScriptTag","qualifiedName":"analyzer/analyzer.ScriptTag","preview":"<p>Instances of the class <code>ScriptTag</code> represent the script tag that can optionally occur at\nthe beginning of a compilation unit.</p>"},{"name":"ShowCombinator","qualifiedName":"analyzer/analyzer.ShowCombinator","preview":"<p>Instances of the class <code>ShowCombinator</code> represent a combinator that restricts the names\nbeing imported to those in a given list.</p>"},{"name":"SimpleAstVisitor","qualifiedName":"analyzer/analyzer.SimpleAstVisitor","preview":"<p>Instances of the class <code>SimpleAstVisitor</code> implement an AST visitor that will do nothing\nwhen visiting an AST node. It is intended to be a superclass for classes that use the visitor\npattern primarily as a dispatch mechanism (and hence don't need to recursively visit a whole\nstructure) and that only need to visit a small number of node types.</p>"},{"name":"SimpleFormalParameter","qualifiedName":"analyzer/analyzer.SimpleFormalParameter","preview":"<p>Instances of the class <code>SimpleFormalParameter</code> represent a simple formal parameter.</p>"},{"name":"SimpleIdentifier","qualifiedName":"analyzer/analyzer.SimpleIdentifier","preview":"<p>Instances of the class <code>SimpleIdentifier</code> represent a simple identifier.</p>"},{"name":"SimpleStringLiteral","qualifiedName":"analyzer/analyzer.SimpleStringLiteral","preview":"<p>Instances of the class <code>SimpleStringLiteral</code> represent a string literal expression that\ndoes not contain any interpolations.</p>"},{"name":"Statement","qualifiedName":"analyzer/analyzer.Statement","preview":"<p>Instances of the class <code>Statement</code> defines the behavior common to nodes that represent a\nstatement.</p>"},{"name":"StaticTypeWarningCode","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode","preview":"<p>The enumeration <code>StaticTypeWarningCode</code> defines the error codes used for static type\nwarnings. The convention for this class is for the name of the error code to indicate the problem\nthat caused the error to be generated and for the error message to explain what is wrong and,\nwhen appropriate, how the problem can be corrected.</p>"},{"name":"StaticWarningCode","qualifiedName":"analyzer/analyzer.StaticWarningCode","preview":"<p>The enumeration <code>StaticWarningCode</code> defines the error codes used for static warnings. The\nconvention for this class is for the name of the error code to indicate the problem that caused\nthe error to be generated and for the error message to explain what is wrong and, when\nappropriate, how the problem can be corrected.</p>"},{"name":"StringInterpolation","qualifiedName":"analyzer/analyzer.StringInterpolation","preview":"<p>Instances of the class <code>StringInterpolation</code> represent a string interpolation literal.</p>"},{"name":"StringLiteral","qualifiedName":"analyzer/analyzer.StringLiteral","preview":"<p>Instances of the class <code>StringLiteral</code> represent a string literal expression.</p>"},{"name":"SuperConstructorInvocation","qualifiedName":"analyzer/analyzer.SuperConstructorInvocation","preview":"<p>Instances of the class <code>SuperConstructorInvocation</code> represent the invocation of a\nsuperclass' constructor from within a constructor's initialization list.</p>"},{"name":"SuperExpression","qualifiedName":"analyzer/analyzer.SuperExpression","preview":"<p>Instances of the class <code>SuperExpression</code> represent a super expression.</p>"},{"name":"SwitchCase","qualifiedName":"analyzer/analyzer.SwitchCase","preview":"<p>Instances of the class <code>SwitchCase</code> represent the case in a switch statement.</p>"},{"name":"SwitchDefault","qualifiedName":"analyzer/analyzer.SwitchDefault","preview":"<p>Instances of the class <code>SwitchDefault</code> represent the default case in a switch statement.</p>"},{"name":"SwitchMember","qualifiedName":"analyzer/analyzer.SwitchMember","preview":"<p>The abstract class <code>SwitchMember</code> defines the behavior common to objects representing\nelements within a switch statement.</p>"},{"name":"SwitchStatement","qualifiedName":"analyzer/analyzer.SwitchStatement","preview":"<p>Instances of the class <code>SwitchStatement</code> represent a switch statement.</p>"},{"name":"SymbolLiteral","qualifiedName":"analyzer/analyzer.SymbolLiteral","preview":"<p>Instances of the class <code>SymbolLiteral</code> represent a symbol literal expression.</p>"},{"name":"ThisExpression","qualifiedName":"analyzer/analyzer.ThisExpression","preview":"<p>Instances of the class <code>ThisExpression</code> represent a this expression.</p>"},{"name":"ThrowExpression","qualifiedName":"analyzer/analyzer.ThrowExpression","preview":"<p>Instances of the class <code>ThrowExpression</code> represent a throw expression.</p>"},{"name":"ToSourceVisitor","qualifiedName":"analyzer/analyzer.ToSourceVisitor","preview":"<p>Instances of the class <code>ToSourceVisitor</code> write a source representation of a visited AST\nnode (and all of it's children) to a writer.</p>"},{"name":"TodoCode","qualifiedName":"analyzer/analyzer.TodoCode","preview":"<p>The enumeration <code>TodoCode</code> defines the single TODO <code>ErrorCode</code>.</p>"},{"name":"TopLevelVariableDeclaration","qualifiedName":"analyzer/analyzer.TopLevelVariableDeclaration","preview":"<p>Instances of the class <code>TopLevelVariableDeclaration</code> represent the declaration of one or\nmore top-level variables of the same type.</p>"},{"name":"TryStatement","qualifiedName":"analyzer/analyzer.TryStatement","preview":"<p>Instances of the class <code>TryStatement</code> represent a try statement.</p>"},{"name":"TypeAlias","qualifiedName":"analyzer/analyzer.TypeAlias","preview":"<p>The abstract class <code>TypeAlias</code> defines the behavior common to declarations of type aliases.</p>"},{"name":"TypeArgumentList","qualifiedName":"analyzer/analyzer.TypeArgumentList","preview":"<p>Instances of the class <code>TypeArgumentList</code> represent a list of type arguments.</p>"},{"name":"TypeName","qualifiedName":"analyzer/analyzer.TypeName","preview":"<p>Instances of the class <code>TypeName</code> represent the name of a type, which can optionally\ninclude type arguments.</p>"},{"name":"TypeParameter","qualifiedName":"analyzer/analyzer.TypeParameter","preview":"<p>Instances of the class <code>TypeParameter</code> represent a type parameter.</p>"},{"name":"TypeParameterList","qualifiedName":"analyzer/analyzer.TypeParameterList","preview":"<p>Instances of the class <code>TypeParameterList</code> represent type parameters within a declaration.</p>"},{"name":"TypedLiteral","qualifiedName":"analyzer/analyzer.TypedLiteral","preview":"<p>The abstract class <code>TypedLiteral</code> defines the behavior common to literals that have a type\nassociated with them.</p>"},{"name":"UnifyingAstVisitor","qualifiedName":"analyzer/analyzer.UnifyingAstVisitor","preview":"<p>Instances of the class <code>UnifyingAstVisitor</code> implement an AST visitor that will recursively\nvisit all of the nodes in an AST structure (like instances of the class\n<a>analyzer/analyzer.RecursiveAstVisitor</a>). In addition, every node will also be visited by using a single\nunified <a>analyzer/analyzer.UnifyingAstVisitor.visitNode</a> method.</p>"},{"name":"UriBasedDirective","qualifiedName":"analyzer/analyzer.UriBasedDirective","preview":"<p>The abstract class <code>UriBasedDirective</code> defines the behavior common to nodes that represent\na directive that references a URI.</p>"},{"name":"VariableDeclaration","qualifiedName":"analyzer/analyzer.VariableDeclaration","preview":"<p>Instances of the class <code>VariableDeclaration</code> represent an identifier that has an initial\nvalue associated with it. Instances of this class are always children of the class\n<a>analyzer/analyzer.VariableDeclarationList</a>.</p>"},{"name":"VariableDeclarationList","qualifiedName":"analyzer/analyzer.VariableDeclarationList","preview":"<p>Instances of the class <code>VariableDeclarationList</code> represent the declaration of one or more\nvariables of the same type.</p>"},{"name":"VariableDeclarationStatement","qualifiedName":"analyzer/analyzer.VariableDeclarationStatement","preview":"<p>Instances of the class <code>VariableDeclarationStatement</code> represent a list of variables that\nare being declared in a context where a statement is required.</p>"},{"name":"WhileStatement","qualifiedName":"analyzer/analyzer.WhileStatement","preview":"<p>Instances of the class <code>WhileStatement</code> represent a while statement.</p>"},{"name":"WithClause","qualifiedName":"analyzer/analyzer.WithClause","preview":"<p>Instances of the class <code>WithClause</code> represent the with clause in a class declaration.</p>"}],"typedef":{},"error":[{"name":"AnalyzerError","qualifiedName":"analyzer/analyzer.AnalyzerError","preview":"<p>A wrapper around <a>analyzer/analyzer.AnalysisError</a> that provides a more user-friendly string\nrepresentation.</p>"},{"name":"AnalyzerErrorGroup","qualifiedName":"analyzer/analyzer.AnalyzerErrorGroup","preview":"<p>An error class that collects multiple <a>analyzer/analyzer.AnalyzerError</a>s that are emitted\nduring a single analysis.</p>"},{"name":"NodeLocator_NodeFoundException","qualifiedName":"analyzer/analyzer.NodeLocator_NodeFoundException","preview":"<p>Instances of the class <code>NodeFoundException</code> are used to cancel visiting after a node has\nbeen found.</p>"}]},"packageName":"analyzer","packageIntro":"<p>This code is part of an experimental port of the Editor's analysis engine from\nJava to Dart. While we will continue to support the Java version of the analysis\nengine and the services built on it, we also intend to provide the same services\nto Dart-based applications. This is very early code and we expect it to change,\npossibly in significant ways. While we are eager to see other people make use\nof the analysis engine, we also want to be clear, in case you are interested in\ndoing so, that the current API's should in no way be considered to be stable.</p>\n<p>In particular, this code was automatically translated from the Java\nimplementation. The Java implementation that was translated is still under\ndevelopment and will continue to change over time. The translator that was used\nis still under development and the output produced by the translator will change\nover time. Therefore, the API presented by this code will change. In addition,\nany edits made to this code will be overwritten the next time we re-generate\nthis code.</p>\n<p>If you are interested in using this code, despite the disclaimer above,\nfantastic! Please let the editor team know so that we can get a sense of the\ninterest in it. Also, feel free to ask questions and make requests for\nadditional functionality.</p>"}