{"name":"StaticTypeWarningCode","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode","comment":"<p>The enumeration <code>StaticTypeWarningCode</code> defines the error codes used for static type\nwarnings. The convention for this class is for the name of the error code to indicate the problem\nthat caused the error to be generated and for the error message to explain what is wrong and,\nwhen appropriate, how the problem can be corrected.</p>","isAbstract":false,"superclass":"analyzer/analyzer.Enum","implements":["analyzer/analyzer.ErrorCode"],"subclass":[],"variables":{"EXPECTED_ONE_LIST_TYPE_ARGUMENTS":{"name":"EXPECTED_ONE_LIST_TYPE_ARGUMENTS","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.EXPECTED_ONE_LIST_TYPE_ARGUMENTS","comment":"<p>12.7 Lists: A fresh instance (7.6.1) &lt;i>a&lt;/i>, of size &lt;i>n&lt;/i>, whose class implements the\nbuilt-in class &lt;i>List&lt;E>&lt;/i> is allocated.</p>\n<p>@param numTypeArgument the number of provided type arguments</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"EXPECTED_TWO_MAP_TYPE_ARGUMENTS":{"name":"EXPECTED_TWO_MAP_TYPE_ARGUMENTS","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.EXPECTED_TWO_MAP_TYPE_ARGUMENTS","comment":"<p>12.8 Maps: A fresh instance (7.6.1) &lt;i>m&lt;/i>, of size &lt;i>n&lt;/i>, whose class implements the\nbuilt-in class &lt;i>Map&lt;K, V>&lt;/i> is allocated.</p>\n<p>@param numTypeArgument the number of provided type arguments</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"INACCESSIBLE_SETTER":{"name":"INACCESSIBLE_SETTER","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.INACCESSIBLE_SETTER","comment":"<p>12.18 Assignment: Let &lt;i>T&lt;/i> be the static type of &lt;i>e&lt;sub>1&lt;/sub>&lt;/i>. It is a static type\nwarning if &lt;i>T&lt;/i> does not have an accessible instance setter named &lt;i>v=&lt;/i>.</p>\n<p>@see #UNDEFINED_SETTER</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"INCONSISTENT_METHOD_INHERITANCE":{"name":"INCONSISTENT_METHOD_INHERITANCE","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.INCONSISTENT_METHOD_INHERITANCE","comment":"<p>8.1.1 Inheritance and Overriding: However, if the above rules would cause multiple members\n&lt;i>m&lt;sub>1&lt;/sub>, &hellip;, m&lt;sub>k&lt;/sub>&lt;/i> with the same name &lt;i>n&lt;/i> that would be\ninherited (because identically named members existed in several superinterfaces) then at most\none member is inherited.</p>\n<p>If the static types &lt;i>T&lt;sub>1&lt;/sub>, &hellip;, T&lt;sub>k&lt;/sub>&lt;/i> of the members\n&lt;i>m&lt;sub>1&lt;/sub>, &hellip;, m&lt;sub>k&lt;/sub>&lt;/i> are not identical, then there must be a member\n&lt;i>m&lt;sub>x&lt;/sub>&lt;/i> such that &lt;i>T&lt;sub>x&lt;/sub> &lt;: T&lt;sub>i&lt;/sub>, 1 &lt;= x &lt;= k&lt;/i> for\nall &lt;i>i, 1 &lt;= i &lt;= k&lt;/i>, or a static type warning occurs. The member that is inherited\nis &lt;i>m&lt;sub>x&lt;/sub>&lt;/i>, if it exists; otherwise:\n<em> Let &lt;i>numberOfPositionals&lt;/i>(&lt;i>f&lt;/i>) denote the number of positional parameters of a\nfunction &lt;i>f&lt;/i>, and let &lt;i>numberOfRequiredParams&lt;/i>(&lt;i>f&lt;/i>) denote the number of\nrequired parameters of a function &lt;i>f&lt;/i>. Furthermore, let &lt;i>s&lt;/i> denote the set of all\nnamed parameters of the &lt;i>m&lt;sub>1&lt;/sub>, &hellip;, m&lt;sub>k&lt;/sub>&lt;/i>. Then let\n</em> &lt;i>h = max(numberOfPositionals(m&lt;sub>i&lt;/sub>)),&lt;/i>\n<em> &lt;i>r = min(numberOfRequiredParams(m&lt;sub>i&lt;/sub>)), for all &lt;i>i&lt;/i>, 1 &lt;= i &lt;= k.&lt;/i>\nIf &lt;i>r &lt;= h&lt;/i> then &lt;i>I&lt;/i> has a method named &lt;i>n&lt;/i>, with &lt;i>r&lt;/i> required parameters\nof type &lt;b>dynamic&lt;/b>, &lt;i>h&lt;/i> positional parameters of type &lt;b>dynamic&lt;/b>, named parameters\n&lt;i>s&lt;/i> of type &lt;b>dynamic&lt;/b> and return type &lt;b>dynamic&lt;/b>.\n</em> Otherwise none of the members &lt;i>m&lt;sub>1&lt;/sub>, &hellip;, m&lt;sub>k&lt;/sub>&lt;/i> is inherited.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"INSTANCE_ACCESS_TO_STATIC_MEMBER":{"name":"INSTANCE_ACCESS_TO_STATIC_MEMBER","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.INSTANCE_ACCESS_TO_STATIC_MEMBER","comment":"<p>12.15.1 Ordinary Invocation: It is a static type warning if &lt;i>T&lt;/i> does not have an\naccessible (3.2) instance member named &lt;i>m&lt;/i>.</p>\n<p>@param memberName the name of the static member\n@see UNQUALIFIED<em>REFERENCE</em>TO<em>NON</em>LOCAL<em>STATIC</em>MEMBER</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"INVALID_ASSIGNMENT":{"name":"INVALID_ASSIGNMENT","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.INVALID_ASSIGNMENT","comment":"<p>12.18 Assignment: It is a static type warning if the static type of &lt;i>e&lt;/i> may not be\nassigned to the static type of &lt;i>v&lt;/i>. The static type of the expression &lt;i>v = e&lt;/i> is the\nstatic type of &lt;i>e&lt;/i>.</p>\n<p>12.18 Assignment: It is a static type warning if the static type of &lt;i>e&lt;/i> may not be\nassigned to the static type of &lt;i>C.v&lt;/i>. The static type of the expression &lt;i>C.v = e&lt;/i> is\nthe static type of &lt;i>e&lt;/i>.</p>\n<p>12.18 Assignment: Let &lt;i>T&lt;/i> be the static type of &lt;i>e&lt;sub>1&lt;/sub>&lt;/i>. It is a static type\nwarning if the static type of &lt;i>e&lt;sub>2&lt;/sub>&lt;/i> may not be assigned to &lt;i>T&lt;/i>.</p>\n<p>@param rhsTypeName the name of the right hand side type\n@param lhsTypeName the name of the left hand side type</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"INVOCATION_OF_NON_FUNCTION":{"name":"INVOCATION_OF_NON_FUNCTION","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.INVOCATION_OF_NON_FUNCTION","comment":"<p>12.15.1 Ordinary Invocation: An ordinary method invocation &lt;i>i&lt;/i> has the form\n&lt;i>o.m(a&lt;sub>1&lt;/sub>, &hellip;, a&lt;sub>n&lt;/sub>, x&lt;sub>n+1&lt;/sub>: a&lt;sub>n+1&lt;/sub>, &hellip;\nx&lt;sub>n+k&lt;/sub>: a&lt;sub>n+k&lt;/sub>)&lt;/i>.</p>\n<p>Let &lt;i>T&lt;/i> be the static type of &lt;i>o&lt;/i>. It is a static type warning if &lt;i>T&lt;/i> does not\nhave an accessible instance member named &lt;i>m&lt;/i>. If &lt;i>T.m&lt;/i> exists, it is a static warning\nif the type &lt;i>F&lt;/i> of &lt;i>T.m&lt;/i> may not be assigned to a function type. If &lt;i>T.m&lt;/i> does\nnot exist, or if &lt;i>F&lt;/i> is not a function type, the static type of &lt;i>i&lt;/i> is dynamic.</p>\n<p>12.15.3 Static Invocation: It is a static type warning if the type &lt;i>F&lt;/i> of &lt;i>C.m&lt;/i> may\nnot be assigned to a function type.</p>\n<p>12.15.4 Super Invocation: A super method invocation &lt;i>i&lt;/i> has the form\n&lt;i>super.m(a&lt;sub>1&lt;/sub>, &hellip;, a&lt;sub>n&lt;/sub>, x&lt;sub>n+1&lt;/sub>: a&lt;sub>n+1&lt;/sub>, &hellip;\nx&lt;sub>n+k&lt;/sub>: a&lt;sub>n+k&lt;/sub>)&lt;/i>. If &lt;i>S.m&lt;/i> exists, it is a static warning if the type\n&lt;i>F&lt;/i> of &lt;i>S.m&lt;/i> may not be assigned to a function type.</p>\n<p>@param nonFunctionIdentifier the name of the identifier that is not a function type</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"INVOCATION_OF_NON_FUNCTION_EXPRESSION":{"name":"INVOCATION_OF_NON_FUNCTION_EXPRESSION","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.INVOCATION_OF_NON_FUNCTION_EXPRESSION","comment":"<p>12.14.4 Function Expression Invocation: A function expression invocation &lt;i>i&lt;/i> has the form\n&lt;i>e&lt;sub>f&lt;/sub>(a&lt;sub>1&lt;/sub>, &hellip;, a&lt;sub>n&lt;/sub>, x&lt;sub>n+1&lt;/sub>: a&lt;sub>n+1&lt;/sub>,\n&hellip;, x&lt;sub>n+k&lt;/sub>: a&lt;sub>n+k&lt;/sub>)&lt;/i>, where &lt;i>e&lt;sub>f&lt;/sub>&lt;/i> is an expression.</p>\n<p>It is a static type warning if the static type &lt;i>F&lt;/i> of &lt;i>e&lt;sub>f&lt;/sub>&lt;/i> may not be\nassigned to a function type.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"NON_BOOL_CONDITION":{"name":"NON_BOOL_CONDITION","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.NON_BOOL_CONDITION","comment":"<p>12.20 Conditional: It is a static type warning if the type of &lt;i>e&lt;sub>1&lt;/sub>&lt;/i> may not be\nassigned to bool.</p>\n<p>13.5 If: It is a static type warning if the type of the expression &lt;i>b&lt;/i> may not be assigned\nto bool.</p>\n<p>13.7 While: It is a static type warning if the type of &lt;i>e&lt;/i> may not be assigned to bool.</p>\n<p>13.8 Do: It is a static type warning if the type of &lt;i>e&lt;/i> cannot be assigned to bool.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"NON_BOOL_EXPRESSION":{"name":"NON_BOOL_EXPRESSION","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.NON_BOOL_EXPRESSION","comment":"<p>13.15 Assert: It is a static type warning if the type of &lt;i>e&lt;/i> may not be assigned to either\nbool or () &rarr; bool</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"NON_BOOL_NEGATION_EXPRESSION":{"name":"NON_BOOL_NEGATION_EXPRESSION","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.NON_BOOL_NEGATION_EXPRESSION","comment":"<p>12.28 Unary Expressions: The expression !&lt;i>e&lt;/i> is equivalent to the expression\n&lt;i>e&lt;/i>?&lt;b>false&lt;b> : &lt;b>true&lt;/b>.</p>\n<p>12.20 Conditional: It is a static type warning if the type of &lt;i>e&lt;sub>1&lt;/sub>&lt;/i> may not be\nassigned to bool.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"NON_TYPE_AS_TYPE_ARGUMENT":{"name":"NON_TYPE_AS_TYPE_ARGUMENT","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.NON_TYPE_AS_TYPE_ARGUMENT","comment":"<p>15.8 Parameterized Types: It is a static type warning if &lt;i>A&lt;sub>i&lt;/sub>, 1 &lt;= i &lt;=\nn&lt;/i> does not denote a type in the enclosing lexical scope.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"RETURN_OF_INVALID_TYPE":{"name":"RETURN_OF_INVALID_TYPE","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.RETURN_OF_INVALID_TYPE","comment":"<p>13.11 Return: It is a static type warning if the type of &lt;i>e&lt;/i> may not be assigned to the\ndeclared return type of the immediately enclosing function.</p>\n<p>@param actualReturnType the return type as declared in the return statement\n@param expectedReturnType the expected return type as defined by the method\n@param methodName the name of the method</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"TYPE_ARGUMENT_NOT_MATCHING_BOUNDS":{"name":"TYPE_ARGUMENT_NOT_MATCHING_BOUNDS","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.TYPE_ARGUMENT_NOT_MATCHING_BOUNDS","comment":"<p>12.11 Instance Creation: It is a static type warning if any of the type arguments to a\nconstructor of a generic type &lt;i>G&lt;/i> invoked by a new expression or a constant object\nexpression are not subtypes of the bounds of the corresponding formal type parameters of\n&lt;i>G&lt;/i>.</p>\n<p>15.8 Parameterized Types: If &lt;i>S&lt;/i> is the static type of a member &lt;i>m&lt;/i> of &lt;i>G&lt;/i>, then\nthe static type of the member &lt;i>m&lt;/i> of &lt;i>G&lt;A&lt;sub>1&lt;/sub>, &hellip;,\nA&lt;sub>n&lt;/sub>&gt;&lt;/i> is &lt;i>A&lt;sub>1&lt;/sub>, &hellip;, A&lt;sub>n&lt;/sub>/T&lt;sub>1&lt;/sub>, &hellip;,\nT&lt;sub>n&lt;/sub>S&lt;/i> where &lt;i>T&lt;sub>1&lt;/sub>, &hellip;, T&lt;sub>n&lt;/sub>&lt;/i> are the formal type\nparameters of &lt;i>G&lt;/i>. Let &lt;i>B&lt;sub>i&lt;/sub>&lt;/i> be the bounds of &lt;i>T&lt;sub>i&lt;/sub>, 1 &lt;= i\n&lt;= n&lt;/i>. It is a static type warning if &lt;i>A&lt;sub>i&lt;/sub>&lt;/i> is not a subtype of\n&lt;i>A&lt;sub>1&lt;/sub>, &hellip;, A&lt;sub>n&lt;/sub>/T&lt;sub>1&lt;/sub>, &hellip;,\nT&lt;sub>n&lt;/sub>B&lt;sub>i&lt;/sub>, 1 &lt;= i &lt;= n&lt;/i>.</p>\n<p>7.6.2 Factories: It is a static type warning if any of the type arguments to &lt;i>k'&lt;/i> are not\nsubtypes of the bounds of the corresponding formal type parameters of type.</p>\n<p>@param boundedTypeName the name of the type used in the instance creation that should be</p>\n<pre><code>     limited by the bound as specified in the class declaration\n</code></pre>\n<p>@param boundingTypeName the name of the bounding type\n@see #TYPE<em>PARAMETER</em>SUPERTYPE<em>OF</em>ITS_BOUND</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"TYPE_PARAMETER_SUPERTYPE_OF_ITS_BOUND":{"name":"TYPE_PARAMETER_SUPERTYPE_OF_ITS_BOUND","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.TYPE_PARAMETER_SUPERTYPE_OF_ITS_BOUND","comment":"<p>10 Generics: It is a static type warning if a type parameter is a supertype of its upper bound.</p>\n<p>@param typeParameterName the name of the type parameter\n@see #TYPE<em>ARGUMENT</em>NOT<em>MATCHING</em>BOUNDS</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"UNDEFINED_FUNCTION":{"name":"UNDEFINED_FUNCTION","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.UNDEFINED_FUNCTION","comment":"<p>12.15.3 Unqualified Invocation: If there exists a lexically visible declaration named\n&lt;i>id&lt;/i>, let &lt;i>f&lt;sub>id&lt;/sub>&lt;/i> be the innermost such declaration. Then: skip.\nOtherwise, &lt;i>f&lt;sub>id&lt;/sub>&lt;/i> is considered equivalent to the ordinary method invocation\n&lt;b>this&lt;/b>.&lt;i>id&lt;/i>(&lt;i>a&lt;sub>1&lt;/sub>&lt;/i>, ..., &lt;i>a&lt;sub>n&lt;/sub>&lt;/i>, &lt;i>x&lt;sub>n+1&lt;/sub>&lt;/i> :\n&lt;i>a&lt;sub>n+1&lt;/sub>&lt;/i>, ..., &lt;i>x&lt;sub>n+k&lt;/sub>&lt;/i> : &lt;i>a&lt;sub>n+k&lt;/sub>&lt;/i>).</p>\n<p>@param methodName the name of the method that is undefined</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"UNDEFINED_GETTER":{"name":"UNDEFINED_GETTER","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.UNDEFINED_GETTER","comment":"<p>12.17 Getter Invocation: Let &lt;i>T&lt;/i> be the static type of &lt;i>e&lt;/i>. It is a static type\nwarning if &lt;i>T&lt;/i> does not have a getter named &lt;i>m&lt;/i>.</p>\n<p>@param getterName the name of the getter\n@param enclosingType the name of the enclosing type where the getter is being looked for</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"UNDEFINED_METHOD":{"name":"UNDEFINED_METHOD","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.UNDEFINED_METHOD","comment":"<p>12.15.1 Ordinary Invocation: Let &lt;i>T&lt;/i> be the static type of &lt;i>o&lt;/i>. It is a static type\nwarning if &lt;i>T&lt;/i> does not have an accessible instance member named &lt;i>m&lt;/i>.</p>\n<p>@param methodName the name of the method that is undefined\n@param typeName the resolved type name that the method lookup is happening on</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"UNDEFINED_OPERATOR":{"name":"UNDEFINED_OPERATOR","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.UNDEFINED_OPERATOR","comment":"<p>12.18 Assignment: Evaluation of an assignment of the form\n&lt;i>e&lt;sub>1&lt;/sub>&lt;/i>&lt;i>e&lt;sub>2&lt;/sub>&lt;/i> = &lt;i>e&lt;sub>3&lt;/sub>&lt;/i> is equivalent to the\nevaluation of the expression (a, i, e){a.=(i, e); return e;} (&lt;i>e&lt;sub>1&lt;/sub>&lt;/i>,\n&lt;i>e&lt;sub>2&lt;/sub>&lt;/i>, &lt;i>e&lt;sub>2&lt;/sub>&lt;/i>).</p>\n<p>12.29 Assignable Expressions: An assignable expression of the form\n&lt;i>e&lt;sub>1&lt;/sub>&lt;/i>&lt;i>e&lt;sub>2&lt;/sub>&lt;/i> is evaluated as a method invocation of the operator\nmethod  on &lt;i>e&lt;sub>1&lt;/sub>&lt;/i> with argument &lt;i>e&lt;sub>2&lt;/sub>&lt;/i>.</p>\n<p>12.15.1 Ordinary Invocation: Let &lt;i>T&lt;/i> be the static type of &lt;i>o&lt;/i>. It is a static type\nwarning if &lt;i>T&lt;/i> does not have an accessible instance member named &lt;i>m&lt;/i>.</p>\n<p>@param operator the name of the operator\n@param enclosingType the name of the enclosing type where the operator is being looked for</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"UNDEFINED_SETTER":{"name":"UNDEFINED_SETTER","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.UNDEFINED_SETTER","comment":"<p>12.18 Assignment: Let &lt;i>T&lt;/i> be the static type of &lt;i>e&lt;sub>1&lt;/sub>&lt;/i>. It is a static type\nwarning if &lt;i>T&lt;/i> does not have an accessible instance setter named &lt;i>v=&lt;/i>.</p>\n<p>@param setterName the name of the setter\n@param enclosingType the name of the enclosing type where the setter is being looked for\n@see #INACCESSIBLE_SETTER</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"UNDEFINED_SUPER_METHOD":{"name":"UNDEFINED_SUPER_METHOD","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.UNDEFINED_SUPER_METHOD","comment":"<p>12.15.4 Super Invocation: A super method invocation &lt;i>i&lt;/i> has the form\n&lt;i>super.m(a&lt;sub>1&lt;/sub>, &hellip;, a&lt;sub>n&lt;/sub>, x&lt;sub>n+1&lt;/sub>: a&lt;sub>n+1&lt;/sub>, &hellip;\nx&lt;sub>n+k&lt;/sub>: a&lt;sub>n+k&lt;/sub>)&lt;/i>. It is a static type warning if &lt;i>S&lt;/i> does not have an\naccessible instance member named &lt;i>m&lt;/i>.</p>\n<p>@param methodName the name of the method that is undefined\n@param typeName the resolved type name that the method lookup is happening on</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"UNQUALIFIED_REFERENCE_TO_NON_LOCAL_STATIC_MEMBER":{"name":"UNQUALIFIED_REFERENCE_TO_NON_LOCAL_STATIC_MEMBER","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.UNQUALIFIED_REFERENCE_TO_NON_LOCAL_STATIC_MEMBER","comment":"<p>12.15.1 Ordinary Invocation: It is a static type warning if &lt;i>T&lt;/i> does not have an\naccessible (3.2) instance member named &lt;i>m&lt;/i>.</p>\n<p>This is a specialization of [INSTANCE_ACCESS_TO_STATIC_MEMBER] that is used when we are\nable to find the name defined in a supertype. It exists to provide a more informative error\nmessage.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"WRONG_NUMBER_OF_TYPE_ARGUMENTS":{"name":"WRONG_NUMBER_OF_TYPE_ARGUMENTS","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.WRONG_NUMBER_OF_TYPE_ARGUMENTS","comment":"<p>15.8 Parameterized Types: It is a static type warning if &lt;i>G&lt;/i> is not a generic type with\nexactly &lt;i>n&lt;/i> type parameters.</p>\n<p>@param typeName the name of the type being referenced (&lt;i>G&lt;/i>)\n@param parameterCount the number of type parameters that were declared\n@param argumentCount the number of type arguments provided\n@see CompileTimeErrorCode#CONST<em>WITH</em>INVALID<em>TYPE</em>PARAMETERS\n@see CompileTimeErrorCode#NEW<em>WITH</em>INVALID<em>TYPE</em>PARAMETERS</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}],"annotations":[]},"correction":{"name":"correction","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.correction","comment":"<p>The template used to create the correction to be displayed for this error, or <code>null</code> if\nthere is no correction information for this error.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"message":{"name":"message","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.message","comment":"<p>The template used to create the message to be displayed for this error.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"values":{"name":"values","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.values","comment":"","final":false,"static":true,"constant":true,"type":[{"outer":"dart-core.List","inner":[{"outer":"analyzer/analyzer.StaticTypeWarningCode","inner":[]}]}],"annotations":[]}},"inheritedVariables":{"name":{"name":"name","qualifiedName":"analyzer/analyzer.Enum.name","comment":"<p>The name of this enum constant, as declared in the enum declaration.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"ordinal":{"name":"ordinal","qualifiedName":"analyzer/analyzer.Enum.ordinal","comment":"<p>The position in the enum declaration.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.int","inner":[]}],"annotations":[]}},"methods":{"setters":{},"getters":{"errorSeverity":{"name":"errorSeverity","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.errorSeverity","comment":"<p>Return the severity of this error.</p>\n<p>@return the severity of this error</p>","commentFrom":"analyzer.ErrorCode.errorSeverity","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/analyzer.ErrorSeverity","inner":[]}],"parameters":{},"annotations":[{"name":"analyzer/dart-core.override","parameters":[]}]},"type":{"name":"type","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.type","comment":"<p>Return the type of the error.</p>\n<p>@return the type of the error</p>","commentFrom":"analyzer.ErrorCode.type","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/analyzer.ErrorType","inner":[]}],"parameters":{},"annotations":[{"name":"analyzer/dart-core.override","parameters":[]}]}},"constructors":{"con1":{"name":"con1","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.StaticTypeWarningCode-con1","comment":"<p>Initialize a newly created error code to have the given message.</p>\n<p>@param message the message template used to create the message to be displayed for the error</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":true,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"ordinal":{"name":"ordinal","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"con2":{"name":"con2","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.StaticTypeWarningCode-con2","comment":"<p>Initialize a newly created error code to have the given message and correction.</p>\n<p>@param message the template used to create the message to be displayed for the error\n@param correction the template used to create the correction to be displayed for the error</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":true,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"ordinal":{"name":"ordinal","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"correction":{"name":"correction","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{},"methods":{}},"inheritedMethods":{"setters":{},"getters":{"correction":{"name":"correction","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.correction","comment":"<p>Return the template used to create the correction to be displayed for this error, or\n<code>null</code> if there is no correction information for this error. The correction should\nindicate how the user can fix the error.</p>\n<p>@return the template used to create the correction to be displayed for this error</p>","commentFrom":"","inheritedFrom":"analyzer.ErrorCode.correction","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"errorSeverity":{"name":"errorSeverity","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.errorSeverity","comment":"<p>Return the severity of this error.</p>\n<p>@return the severity of this error</p>","commentFrom":"","inheritedFrom":"analyzer.ErrorCode.errorSeverity","static":false,"abstract":true,"constant":false,"return":[{"outer":"analyzer/analyzer.ErrorSeverity","inner":[]}],"parameters":{},"annotations":[]},"hashCode":{"name":"hashCode","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>analyzer/analyzer.StaticTypeWarningCode.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"message":{"name":"message","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.message","comment":"<p>Return the template used to create the message to be displayed for this error. The message\nshould indicate what is wrong and why it is wrong.</p>\n<p>@return the template used to create the message to be displayed for this error</p>","commentFrom":"","inheritedFrom":"analyzer.ErrorCode.message","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]},"type":{"name":"type","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.type","comment":"<p>Return the type of the error.</p>\n<p>@return the type of the error</p>","commentFrom":"","inheritedFrom":"analyzer.ErrorCode.type","static":false,"abstract":true,"constant":false,"return":[{"outer":"analyzer/analyzer.ErrorType","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>analyzer/analyzer.StaticTypeWarningCode.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>analyzer/analyzer.StaticTypeWarningCode.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"compareTo":{"name":"compareTo","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.compareTo","comment":"<p>Compares this object to another <a>dart-core.Comparable</a></p>\n<p>Returns a value like a <a>dart-core.Comparator</a> when comparing <code>this</code> to <a>analyzer/analyzer.StaticTypeWarningCode.compareTo.other</a>.\nThat is, it returns a negative integer if <code>this</code> is ordered before <a>analyzer/analyzer.StaticTypeWarningCode.compareTo.other</a>,\na positive integer if <code>this</code> is ordered after <a>analyzer/analyzer.StaticTypeWarningCode.compareTo.other</a>,\nand zero if <code>this</code> and <a>analyzer/analyzer.StaticTypeWarningCode.compareTo.other</a> are ordered together.</p>\n<p>The <a>analyzer/analyzer.StaticTypeWarningCode.compareTo.other</a> argument must be a value that is comparable to this object.</p>","commentFrom":"dart-core.Comparable.compareTo","inheritedFrom":"analyzer.Enum.compareTo","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.Enum.E","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.noSuchMethod","comment":"<p><a>analyzer/analyzer.StaticTypeWarningCode.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>analyzer/analyzer.StaticTypeWarningCode.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>analyzer/analyzer.StaticTypeWarningCode.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>analyzer/analyzer.StaticTypeWarningCode.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"analyzer/analyzer.StaticTypeWarningCode.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}