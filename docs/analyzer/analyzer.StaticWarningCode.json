{"name":"StaticWarningCode","qualifiedName":"analyzer/analyzer.StaticWarningCode","comment":"<p>The enumeration <code>StaticWarningCode</code> defines the error codes used for static warnings. The\nconvention for this class is for the name of the error code to indicate the problem that caused\nthe error to be generated and for the error message to explain what is wrong and, when\nappropriate, how the problem can be corrected.</p>","isAbstract":false,"superclass":"analyzer/analyzer.Enum","implements":["analyzer/analyzer.ErrorCode"],"subclass":[],"variables":{"AMBIGUOUS_IMPORT":{"name":"AMBIGUOUS_IMPORT","qualifiedName":"analyzer/analyzer.StaticWarningCode.AMBIGUOUS_IMPORT","comment":"<p>14.1 Imports: If a name &lt;i>N&lt;/i> is referenced by a library &lt;i>L&lt;/i> and &lt;i>N&lt;/i> is introduced\ninto the top level scope &lt;i>L&lt;/i> by more than one import then:\n&lt;ol>\n<em> A static warning occurs.\n</em> If &lt;i>N&lt;/i> is referenced as a function, getter or setter, a &lt;i>NoSuchMethodError&lt;/i> is\nraised.\n* If &lt;i>N&lt;/i> is referenced as a type, it is treated as a malformed type.\n&lt;/ol></p>\n<p>@param ambiguousTypeName the name of the ambiguous type\n@param firstLibraryName the name of the first library that the type is found\n@param secondLibraryName the name of the second library that the type is found</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"ARGUMENT_TYPE_NOT_ASSIGNABLE":{"name":"ARGUMENT_TYPE_NOT_ASSIGNABLE","qualifiedName":"analyzer/analyzer.StaticWarningCode.ARGUMENT_TYPE_NOT_ASSIGNABLE","comment":"<p>12.11.1 New: It is a static warning if the static type of &lt;i>a&lt;sub>i&lt;/sub>, 1 &lt;= i &lt;= n+\nk&lt;/i> may not be assigned to the type of the corresponding formal parameter of the constructor\n&lt;i>T.id&lt;/i> (respectively &lt;i>T&lt;/i>).</p>\n<p>12.11.2 Const: It is a static warning if the static type of &lt;i>a&lt;sub>i&lt;/sub>, 1 &lt;= i &lt;=\nn+ k&lt;/i> may not be assigned to the type of the corresponding formal parameter of the\nconstructor &lt;i>T.id&lt;/i> (respectively &lt;i>T&lt;/i>).</p>\n<p>12.14.2 Binding Actuals to Formals: Let &lt;i>T&lt;sub>i&lt;/sub>&lt;/i> be the static type of\n&lt;i>a&lt;sub>i&lt;/sub>&lt;/i>, let &lt;i>S&lt;sub>i&lt;/sub>&lt;/i> be the type of &lt;i>p&lt;sub>i&lt;/sub>, 1 &lt;= i &lt;=\nn+k&lt;/i> and let &lt;i>S&lt;sub>q&lt;/sub>&lt;/i> be the type of the named parameter &lt;i>q&lt;/i> of &lt;i>f&lt;/i>.\nIt is a static warning if &lt;i>T&lt;sub>j&lt;/sub>&lt;/i> may not be assigned to &lt;i>S&lt;sub>j&lt;/sub>, 1 &lt;=\nj &lt;= m&lt;/i>.</p>\n<p>12.14.2 Binding Actuals to Formals: Furthermore, each &lt;i>q&lt;sub>i&lt;/sub>, 1 &lt;= i &lt;= l&lt;/i>,\nmust have a corresponding named parameter in the set &lt;i>{p&lt;sub>n+1&lt;/sub>, &hellip;\np&lt;sub>n+k&lt;/sub>}&lt;/i> or a static warning occurs. It is a static warning if\n&lt;i>T&lt;sub>m+j&lt;/sub>&lt;/i> may not be assigned to &lt;i>S&lt;sub>r&lt;/sub>&lt;/i>, where &lt;i>r = q&lt;sub>j&lt;/sub>,\n1 &lt;= j &lt;= l&lt;/i>.</p>\n<p>@param actualType the name of the actual argument type\n@param expectedType the name of the expected type</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"ASSIGNMENT_TO_CONST":{"name":"ASSIGNMENT_TO_CONST","qualifiedName":"analyzer/analyzer.StaticWarningCode.ASSIGNMENT_TO_CONST","comment":"<p>5 Variables: Attempting to assign to a final variable elsewhere will cause a NoSuchMethodError\nto be thrown, because no setter is defined for it. The assignment will also give rise to a\nstatic warning for the same reason.</p>\n<p>A constant variable is always implicitly final.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"ASSIGNMENT_TO_FINAL":{"name":"ASSIGNMENT_TO_FINAL","qualifiedName":"analyzer/analyzer.StaticWarningCode.ASSIGNMENT_TO_FINAL","comment":"<p>5 Variables: Attempting to assign to a final variable elsewhere will cause a NoSuchMethodError\nto be thrown, because no setter is defined for it. The assignment will also give rise to a\nstatic warning for the same reason.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"ASSIGNMENT_TO_METHOD":{"name":"ASSIGNMENT_TO_METHOD","qualifiedName":"analyzer/analyzer.StaticWarningCode.ASSIGNMENT_TO_METHOD","comment":"<p>12.18 Assignment: Let &lt;i>T&lt;/i> be the static type of &lt;i>e&lt;sub>1&lt;/sub>&lt;/i>. It is a static type\nwarning if &lt;i>T&lt;/i> does not have an accessible instance setter named &lt;i>v =&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"CASE_BLOCK_NOT_TERMINATED":{"name":"CASE_BLOCK_NOT_TERMINATED","qualifiedName":"analyzer/analyzer.StaticWarningCode.CASE_BLOCK_NOT_TERMINATED","comment":"<p>13.9 Switch: It is a static warning if the last statement of the statement sequence\n&lt;i>s&lt;sub>k&lt;/sub>&lt;/i> is not a break, continue, return or throw statement.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"CAST_TO_NON_TYPE":{"name":"CAST_TO_NON_TYPE","qualifiedName":"analyzer/analyzer.StaticWarningCode.CAST_TO_NON_TYPE","comment":"<p>12.32 Type Cast: It is a static warning if &lt;i>T&lt;/i> does not denote a type available in the\ncurrent lexical scope.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"CONCRETE_CLASS_WITH_ABSTRACT_MEMBER":{"name":"CONCRETE_CLASS_WITH_ABSTRACT_MEMBER","qualifiedName":"analyzer/analyzer.StaticWarningCode.CONCRETE_CLASS_WITH_ABSTRACT_MEMBER","comment":"<p>7.4 Abstract Instance Members: It is a static warning if an abstract member is declared or\ninherited in a concrete class.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"CONFLICTING_DART_IMPORT":{"name":"CONFLICTING_DART_IMPORT","qualifiedName":"analyzer/analyzer.StaticWarningCode.CONFLICTING_DART_IMPORT","comment":"<p>14.1 Imports: If a name &lt;i>N&lt;/i> is referenced by a library &lt;i>L&lt;/i> and &lt;i>N&lt;/i> would be\nintroduced into the top level scope of &lt;i>L&lt;/i> by an import from a library whose URI begins\nwith &lt;i>dart:&lt;/i> and an import from a library whose URI does not begin with &lt;i>dart:&lt;/i>:\n<em> The import from &lt;i>dart:&lt;/i> is implicitly extended by a hide N clause.\n</em> A static warning is issued.</p>\n<p>@param ambiguousName the ambiguous name\n@param sdkLibraryName the name of the dart: library that the element is found\n@param otherLibraryName the name of the non-dart: library that the element is found</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"CONFLICTING_INSTANCE_GETTER_AND_SUPERCLASS_MEMBER":{"name":"CONFLICTING_INSTANCE_GETTER_AND_SUPERCLASS_MEMBER","qualifiedName":"analyzer/analyzer.StaticWarningCode.CONFLICTING_INSTANCE_GETTER_AND_SUPERCLASS_MEMBER","comment":"<p>7.2 Getters: It is a static warning if a class &lt;i>C&lt;/i> declares an instance getter named\n&lt;i>v&lt;/i> and an accessible static member named &lt;i>v&lt;/i> or &lt;i>v=&lt;/i> is declared in a\nsuperclass of &lt;i>C&lt;/i>.</p>\n<p>@param superName the name of the super class declaring a static member</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"CONFLICTING_INSTANCE_METHOD_SETTER":{"name":"CONFLICTING_INSTANCE_METHOD_SETTER","qualifiedName":"analyzer/analyzer.StaticWarningCode.CONFLICTING_INSTANCE_METHOD_SETTER","comment":"<p>7.1 Instance Methods: It is a static warning if a class &lt;i>C&lt;/i> declares an instance method\nnamed &lt;i>n&lt;/i> and has a setter named &lt;i>n=&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"CONFLICTING_INSTANCE_METHOD_SETTER2":{"name":"CONFLICTING_INSTANCE_METHOD_SETTER2","qualifiedName":"analyzer/analyzer.StaticWarningCode.CONFLICTING_INSTANCE_METHOD_SETTER2","comment":"<p>7.1 Instance Methods: It is a static warning if a class &lt;i>C&lt;/i> declares an instance method\nnamed &lt;i>n&lt;/i> and has a setter named &lt;i>n=&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"CONFLICTING_INSTANCE_SETTER_AND_SUPERCLASS_MEMBER":{"name":"CONFLICTING_INSTANCE_SETTER_AND_SUPERCLASS_MEMBER","qualifiedName":"analyzer/analyzer.StaticWarningCode.CONFLICTING_INSTANCE_SETTER_AND_SUPERCLASS_MEMBER","comment":"<p>7.3 Setters: It is a static warning if a class &lt;i>C&lt;/i> declares an instance setter named\n&lt;i>v=&lt;/i> and an accessible static member named &lt;i>v=&lt;/i> or &lt;i>v&lt;/i> is declared in a\nsuperclass of &lt;i>C&lt;/i>.</p>\n<p>@param superName the name of the super class declaring a static member</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"CONFLICTING_STATIC_GETTER_AND_INSTANCE_SETTER":{"name":"CONFLICTING_STATIC_GETTER_AND_INSTANCE_SETTER","qualifiedName":"analyzer/analyzer.StaticWarningCode.CONFLICTING_STATIC_GETTER_AND_INSTANCE_SETTER","comment":"<p>7.2 Getters: It is a static warning if a class declares a static getter named &lt;i>v&lt;/i> and also\nhas a non-static setter named &lt;i>v=&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"CONFLICTING_STATIC_SETTER_AND_INSTANCE_MEMBER":{"name":"CONFLICTING_STATIC_SETTER_AND_INSTANCE_MEMBER","qualifiedName":"analyzer/analyzer.StaticWarningCode.CONFLICTING_STATIC_SETTER_AND_INSTANCE_MEMBER","comment":"<p>7.3 Setters: It is a static warning if a class declares a static setter named &lt;i>v=&lt;/i> and\nalso has a non-static member named &lt;i>v&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"CONST_WITH_ABSTRACT_CLASS":{"name":"CONST_WITH_ABSTRACT_CLASS","qualifiedName":"analyzer/analyzer.StaticWarningCode.CONST_WITH_ABSTRACT_CLASS","comment":"<p>12.11.2 Const: Given an instance creation expression of the form &lt;i>const q(a&lt;sub>1&lt;/sub>,\n&hellip; a&lt;sub>n&lt;/sub>)&lt;/i> it is a static warning if &lt;i>q&lt;/i> is the constructor of an\nabstract class but &lt;i>q&lt;/i> is not a factory constructor.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"EQUAL_KEYS_IN_MAP":{"name":"EQUAL_KEYS_IN_MAP","qualifiedName":"analyzer/analyzer.StaticWarningCode.EQUAL_KEYS_IN_MAP","comment":"<p>12.7 Maps: It is a static warning if the values of any two keys in a map literal are equal.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"EXPORT_DUPLICATED_LIBRARY_NAME":{"name":"EXPORT_DUPLICATED_LIBRARY_NAME","qualifiedName":"analyzer/analyzer.StaticWarningCode.EXPORT_DUPLICATED_LIBRARY_NAME","comment":"<p>14.2 Exports: It is a static warning to export two different libraries with the same name.</p>\n<p>@param uri1 the uri pointing to a first library\n@param uri2 the uri pointing to a second library\n@param name the shared name of the exported libraries</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"EXTRA_POSITIONAL_ARGUMENTS":{"name":"EXTRA_POSITIONAL_ARGUMENTS","qualifiedName":"analyzer/analyzer.StaticWarningCode.EXTRA_POSITIONAL_ARGUMENTS","comment":"<p>12.14.2 Binding Actuals to Formals: It is a static warning if &lt;i>m &lt; h&lt;/i> or if &lt;i>m &gt;\nn&lt;/i>.</p>\n<p>@param requiredCount the maximum number of positional arguments\n@param argumentCount the actual number of positional arguments given\n@see #NOT<em>ENOUGH</em>REQUIRED_ARGUMENTS</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"FIELD_INITIALIZED_IN_INITIALIZER_AND_DECLARATION":{"name":"FIELD_INITIALIZED_IN_INITIALIZER_AND_DECLARATION","qualifiedName":"analyzer/analyzer.StaticWarningCode.FIELD_INITIALIZED_IN_INITIALIZER_AND_DECLARATION","comment":"<ol><li>\n<p>Variables: It is a static warning if a final instance variable that has been initialized at\nits point of declaration is also initialized in a constructor.</p></li></ol>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"FIELD_INITIALIZER_NOT_ASSIGNABLE":{"name":"FIELD_INITIALIZER_NOT_ASSIGNABLE","qualifiedName":"analyzer/analyzer.StaticWarningCode.FIELD_INITIALIZER_NOT_ASSIGNABLE","comment":"<p>7.6.1 Generative Constructors: Execution of an initializer of the form &lt;b>this&lt;/b>.&lt;i>v&lt;/i> =\n&lt;i>e&lt;/i> proceeds as follows: First, the expression &lt;i>e&lt;/i> is evaluated to an object\n&lt;i>o&lt;/i>. Then, the instance variable &lt;i>v&lt;/i> of the object denoted by this is bound to\n&lt;i>o&lt;/i>.</p>\n<p>12.14.2 Binding Actuals to Formals: Let &lt;i>T&lt;sub>i&lt;/sub>&lt;/i> be the static type of\n&lt;i>a&lt;sub>i&lt;/sub>&lt;/i>, let &lt;i>S&lt;sub>i&lt;/sub>&lt;/i> be the type of &lt;i>p&lt;sub>i&lt;/sub>, 1 &lt;= i &lt;=\nn+k&lt;/i> and let &lt;i>S&lt;sub>q&lt;/sub>&lt;/i> be the type of the named parameter &lt;i>q&lt;/i> of &lt;i>f&lt;/i>.\nIt is a static warning if &lt;i>T&lt;sub>j&lt;/sub>&lt;/i> may not be assigned to &lt;i>S&lt;sub>j&lt;/sub>, 1 &lt;=\nj &lt;= m&lt;/i>.</p>\n<p>@param initializerType the name of the type of the initializer expression\n@param fieldType the name of the type of the field</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"FIELD_INITIALIZING_FORMAL_NOT_ASSIGNABLE":{"name":"FIELD_INITIALIZING_FORMAL_NOT_ASSIGNABLE","qualifiedName":"analyzer/analyzer.StaticWarningCode.FIELD_INITIALIZING_FORMAL_NOT_ASSIGNABLE","comment":"<p>7.6.1 Generative Constructors: An initializing formal has the form &lt;i>this.id&lt;/i>. It is a\nstatic warning if the static type of &lt;i>id&lt;/i> is not assignable to &lt;i>T&lt;sub>id&lt;/sub>&lt;/i>.</p>\n<p>@param parameterType the name of the type of the field formal parameter\n@param fieldType the name of the type of the field</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"FINAL_INITIALIZED_IN_DECLARATION_AND_CONSTRUCTOR":{"name":"FINAL_INITIALIZED_IN_DECLARATION_AND_CONSTRUCTOR","qualifiedName":"analyzer/analyzer.StaticWarningCode.FINAL_INITIALIZED_IN_DECLARATION_AND_CONSTRUCTOR","comment":"<ol><li>\n<p>Variables: It is a static warning if a final instance variable that has been initialized at\nits point of declaration is also initialized in a constructor.</p></li></ol>\n<p>@param name the name of the field in question</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"FINAL_NOT_INITIALIZED":{"name":"FINAL_NOT_INITIALIZED","qualifiedName":"analyzer/analyzer.StaticWarningCode.FINAL_NOT_INITIALIZED","comment":"<p>5 Variables: It is a static warning if a library, static or local variable &lt;i>v&lt;/i> is final\nand &lt;i>v&lt;/i> is not initialized at its point of declaration.</p>\n<p>7.6.1 Generative Constructors: Each final instance variable &lt;i>f&lt;/i> declared in the\nimmediately enclosing class must have an initializer in &lt;i>k&lt;/i>'s initializer list unless it\nhas already been initialized by one of the following means:\n<em> Initialization at the declaration of &lt;i>f&lt;/i>.\n</em> Initialization by means of an initializing formal of &lt;i>k&lt;/i>.\nor a static warning occurs.</p>\n<p>@param name the name of the uninitialized final variable</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"FUNCTION_WITHOUT_CALL":{"name":"FUNCTION_WITHOUT_CALL","qualifiedName":"analyzer/analyzer.StaticWarningCode.FUNCTION_WITHOUT_CALL","comment":"<p>15.5 Function Types: It is a static warning if a concrete class implements Function and does\nnot have a concrete method named call().</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"IMPORT_DUPLICATED_LIBRARY_NAME":{"name":"IMPORT_DUPLICATED_LIBRARY_NAME","qualifiedName":"analyzer/analyzer.StaticWarningCode.IMPORT_DUPLICATED_LIBRARY_NAME","comment":"<p>14.1 Imports: It is a static warning to import two different libraries with the same name.</p>\n<p>@param uri1 the uri pointing to a first library\n@param uri2 the uri pointing to a second library\n@param name the shared name of the imported libraries</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"INCONSISTENT_METHOD_INHERITANCE_GETTER_AND_METHOD":{"name":"INCONSISTENT_METHOD_INHERITANCE_GETTER_AND_METHOD","qualifiedName":"analyzer/analyzer.StaticWarningCode.INCONSISTENT_METHOD_INHERITANCE_GETTER_AND_METHOD","comment":"<p>8.1.1 Inheritance and Overriding: However, if the above rules would cause multiple members\n&lt;i>m&lt;sub>1&lt;/sub>, &hellip;, m&lt;sub>k&lt;/sub>&lt;/i> with the same name &lt;i>n&lt;/i> that would be\ninherited (because identically named members existed in several superinterfaces) then at most\none member is inherited.</p>\n<p>If some but not all of the &lt;i>m&lt;sub>i&lt;/sub>, 1 &lt;= i &lt;= k&lt;/i> are getters none of the\n&lt;i>m&lt;sub>i&lt;/sub>&lt;/i> are inherited, and a static warning is issued.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"INSTANCE_METHOD_NAME_COLLIDES_WITH_SUPERCLASS_STATIC":{"name":"INSTANCE_METHOD_NAME_COLLIDES_WITH_SUPERCLASS_STATIC","qualifiedName":"analyzer/analyzer.StaticWarningCode.INSTANCE_METHOD_NAME_COLLIDES_WITH_SUPERCLASS_STATIC","comment":"<p>7.1 Instance Methods: It is a static warning if a class &lt;i>C&lt;/i> declares an instance method\nnamed &lt;i>n&lt;/i> and an accessible static member named &lt;i>n&lt;/i> is declared in a superclass of\n&lt;i>C&lt;/i>.</p>\n<p>@param memberName the name of the member with the name conflict\n@param superclassName the name of the enclosing class that has the static member</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"INVALID_GETTER_OVERRIDE_RETURN_TYPE":{"name":"INVALID_GETTER_OVERRIDE_RETURN_TYPE","qualifiedName":"analyzer/analyzer.StaticWarningCode.INVALID_GETTER_OVERRIDE_RETURN_TYPE","comment":"<p>7.2 Getters: It is a static warning if a getter &lt;i>m1&lt;/i> overrides a getter &lt;i>m2&lt;/i> and the\ntype of &lt;i>m1&lt;/i> is not a subtype of the type of &lt;i>m2&lt;/i>.</p>\n<p>@param actualReturnTypeName the name of the expected return type\n@param expectedReturnType the name of the actual return type, not assignable to the</p>\n<pre><code>     actualReturnTypeName\n</code></pre>\n<p>@param className the name of the class where the overridden getter is declared\n@see #INVALID<em>METHOD</em>OVERRIDE<em>RETURN</em>TYPE</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"INVALID_METHOD_OVERRIDE_NAMED_PARAM_TYPE":{"name":"INVALID_METHOD_OVERRIDE_NAMED_PARAM_TYPE","qualifiedName":"analyzer/analyzer.StaticWarningCode.INVALID_METHOD_OVERRIDE_NAMED_PARAM_TYPE","comment":"<p>7.1 Instance Methods: It is a static warning if an instance method &lt;i>m1&lt;/i> overrides an\ninstance method &lt;i>m2&lt;/i> and the type of &lt;i>m1&lt;/i> is not a subtype of the type of &lt;i>m2&lt;/i>.</p>\n<p>@param actualParamTypeName the name of the expected parameter type\n@param expectedParamType the name of the actual parameter type, not assignable to the</p>\n<pre><code>     actualParamTypeName\n</code></pre>\n<p>@param className the name of the class where the overridden method is declared</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"INVALID_METHOD_OVERRIDE_NORMAL_PARAM_TYPE":{"name":"INVALID_METHOD_OVERRIDE_NORMAL_PARAM_TYPE","qualifiedName":"analyzer/analyzer.StaticWarningCode.INVALID_METHOD_OVERRIDE_NORMAL_PARAM_TYPE","comment":"<p>7.1 Instance Methods: It is a static warning if an instance method &lt;i>m1&lt;/i> overrides an\ninstance method &lt;i>m2&lt;/i> and the type of &lt;i>m1&lt;/i> is not a subtype of the type of &lt;i>m2&lt;/i>.</p>\n<p>@param actualParamTypeName the name of the expected parameter type\n@param expectedParamType the name of the actual parameter type, not assignable to the</p>\n<pre><code>     actualParamTypeName\n</code></pre>\n<p>@param className the name of the class where the overridden method is declared\n@see #INVALID<em>SETTER</em>OVERRIDE<em>NORMAL</em>PARAM_TYPE</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"INVALID_METHOD_OVERRIDE_OPTIONAL_PARAM_TYPE":{"name":"INVALID_METHOD_OVERRIDE_OPTIONAL_PARAM_TYPE","qualifiedName":"analyzer/analyzer.StaticWarningCode.INVALID_METHOD_OVERRIDE_OPTIONAL_PARAM_TYPE","comment":"<p>7.1 Instance Methods: It is a static warning if an instance method &lt;i>m1&lt;/i> overrides an\ninstance method &lt;i>m2&lt;/i> and the type of &lt;i>m1&lt;/i> is not a subtype of the type of &lt;i>m2&lt;/i>.</p>\n<p>@param actualParamTypeName the name of the expected parameter type\n@param expectedParamType the name of the actual parameter type, not assignable to the</p>\n<pre><code>     actualParamTypeName\n</code></pre>\n<p>@param className the name of the class where the overridden method is declared</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"INVALID_METHOD_OVERRIDE_RETURN_TYPE":{"name":"INVALID_METHOD_OVERRIDE_RETURN_TYPE","qualifiedName":"analyzer/analyzer.StaticWarningCode.INVALID_METHOD_OVERRIDE_RETURN_TYPE","comment":"<p>7.1 Instance Methods: It is a static warning if an instance method &lt;i>m1&lt;/i> overrides an\ninstance method &lt;i>m2&lt;/i> and the type of &lt;i>m1&lt;/i> is not a subtype of the type of &lt;i>m2&lt;/i>.</p>\n<p>@param actualReturnTypeName the name of the expected return type\n@param expectedReturnType the name of the actual return type, not assignable to the</p>\n<pre><code>     actualReturnTypeName\n</code></pre>\n<p>@param className the name of the class where the overridden method is declared\n@see #INVALID<em>GETTER</em>OVERRIDE<em>RETURN</em>TYPE</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"INVALID_OVERRIDE_DIFFERENT_DEFAULT_VALUES_NAMED":{"name":"INVALID_OVERRIDE_DIFFERENT_DEFAULT_VALUES_NAMED","qualifiedName":"analyzer/analyzer.StaticWarningCode.INVALID_OVERRIDE_DIFFERENT_DEFAULT_VALUES_NAMED","comment":"<p>7.1 Instance Methods: It is a static warning if an instance method &lt;i>m1&lt;/i> overrides an\ninstance member &lt;i>m2&lt;/i>, the signature of &lt;i>m2&lt;/i> explicitly specifies a default value for\na formal parameter &lt;i>p&lt;/i> and the signature of &lt;i>m1&lt;/i> specifies a different default value\nfor &lt;i>p&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"INVALID_OVERRIDE_DIFFERENT_DEFAULT_VALUES_POSITIONAL":{"name":"INVALID_OVERRIDE_DIFFERENT_DEFAULT_VALUES_POSITIONAL","qualifiedName":"analyzer/analyzer.StaticWarningCode.INVALID_OVERRIDE_DIFFERENT_DEFAULT_VALUES_POSITIONAL","comment":"<p>7.1 Instance Methods: It is a static warning if an instance method &lt;i>m1&lt;/i> overrides an\ninstance member &lt;i>m2&lt;/i>, the signature of &lt;i>m2&lt;/i> explicitly specifies a default value for\na formal parameter &lt;i>p&lt;/i> and the signature of &lt;i>m1&lt;/i> specifies a different default value\nfor &lt;i>p&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"INVALID_OVERRIDE_NAMED":{"name":"INVALID_OVERRIDE_NAMED","qualifiedName":"analyzer/analyzer.StaticWarningCode.INVALID_OVERRIDE_NAMED","comment":"<p>7.1 Instance Methods: It is a static warning if an instance method &lt;i>m1&lt;/i> overrides an\ninstance member &lt;i>m2&lt;/i> and &lt;i>m1&lt;/i> does not declare all the named parameters declared by\n&lt;i>m2&lt;/i>.</p>\n<p>@param paramCount the number of named parameters in the overridden member\n@param className the name of the class from the overridden method</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"INVALID_OVERRIDE_POSITIONAL":{"name":"INVALID_OVERRIDE_POSITIONAL","qualifiedName":"analyzer/analyzer.StaticWarningCode.INVALID_OVERRIDE_POSITIONAL","comment":"<p>7.1 Instance Methods: It is a static warning if an instance method &lt;i>m1&lt;/i> overrides an\ninstance member &lt;i>m2&lt;/i> and &lt;i>m1&lt;/i> has fewer positional parameters than &lt;i>m2&lt;/i>.</p>\n<p>@param paramCount the number of positional parameters in the overridden member\n@param className the name of the class from the overridden method</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"INVALID_OVERRIDE_REQUIRED":{"name":"INVALID_OVERRIDE_REQUIRED","qualifiedName":"analyzer/analyzer.StaticWarningCode.INVALID_OVERRIDE_REQUIRED","comment":"<p>7.1 Instance Methods: It is a static warning if an instance method &lt;i>m1&lt;/i> overrides an\ninstance member &lt;i>m2&lt;/i> and &lt;i>m1&lt;/i> has a greater number of required parameters than\n&lt;i>m2&lt;/i>.</p>\n<p>@param paramCount the number of required parameters in the overridden member\n@param className the name of the class from the overridden method</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"INVALID_SETTER_OVERRIDE_NORMAL_PARAM_TYPE":{"name":"INVALID_SETTER_OVERRIDE_NORMAL_PARAM_TYPE","qualifiedName":"analyzer/analyzer.StaticWarningCode.INVALID_SETTER_OVERRIDE_NORMAL_PARAM_TYPE","comment":"<p>7.3 Setters: It is a static warning if a setter &lt;i>m1&lt;/i> overrides a setter &lt;i>m2&lt;/i> and the\ntype of &lt;i>m1&lt;/i> is not a subtype of the type of &lt;i>m2&lt;/i>.</p>\n<p>@param actualParamTypeName the name of the expected parameter type\n@param expectedParamType the name of the actual parameter type, not assignable to the</p>\n<pre><code>     actualParamTypeName\n</code></pre>\n<p>@param className the name of the class where the overridden setter is declared\n@see #INVALID<em>METHOD</em>OVERRIDE<em>NORMAL</em>PARAM_TYPE</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"LIST_ELEMENT_TYPE_NOT_ASSIGNABLE":{"name":"LIST_ELEMENT_TYPE_NOT_ASSIGNABLE","qualifiedName":"analyzer/analyzer.StaticWarningCode.LIST_ELEMENT_TYPE_NOT_ASSIGNABLE","comment":"<p>12.6 Lists: A run-time list literal &lt;&lt;i>E&lt;/i>&gt; &lt;i>e&lt;sub>1&lt;/sub>&lt;/i> &hellip;\n&lt;i>e&lt;sub>n&lt;/sub>&lt;/i> is evaluated as follows:\n* The operator = is invoked on &lt;i>a&lt;/i> with first argument &lt;i>i&lt;/i> and second argument\n&lt;i>o&lt;sub>i+1&lt;/sub>&lt;/i>&lt;i>, 1 &lt;= i &lt;= n&lt;/i></p>\n<p>12.14.2 Binding Actuals to Formals: Let &lt;i>T&lt;sub>i&lt;/sub>&lt;/i> be the static type of\n&lt;i>a&lt;sub>i&lt;/sub>&lt;/i>, let &lt;i>S&lt;sub>i&lt;/sub>&lt;/i> be the type of &lt;i>p&lt;sub>i&lt;/sub>, 1 &lt;= i &lt;=\nn+k&lt;/i> and let &lt;i>S&lt;sub>q&lt;/sub>&lt;/i> be the type of the named parameter &lt;i>q&lt;/i> of &lt;i>f&lt;/i>.\nIt is a static warning if &lt;i>T&lt;sub>j&lt;/sub>&lt;/i> may not be assigned to &lt;i>S&lt;sub>j&lt;/sub>, 1 &lt;=\nj &lt;= m&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"MAP_KEY_TYPE_NOT_ASSIGNABLE":{"name":"MAP_KEY_TYPE_NOT_ASSIGNABLE","qualifiedName":"analyzer/analyzer.StaticWarningCode.MAP_KEY_TYPE_NOT_ASSIGNABLE","comment":"<p>12.7 Map: A run-time map literal &lt;&lt;i>K&lt;/i>, &lt;i>V&lt;/i>&gt; &lt;i>k&lt;sub>1&lt;/sub>&lt;/i> :\n&lt;i>e&lt;sub>1&lt;/sub>&lt;/i> &hellip; &lt;i>k&lt;sub>n&lt;/sub>&lt;/i> : &lt;i>e&lt;sub>n&lt;/sub>&lt;/i> is evaluated as\nfollows:\n* The operator = is invoked on &lt;i>m&lt;/i> with first argument &lt;i>k&lt;sub>i&lt;/sub>&lt;/i> and second\nargument &lt;i>e&lt;sub>i&lt;/sub>&lt;/i>&lt;i>, 1 &lt;= i &lt;= n&lt;/i></p>\n<p>12.14.2 Binding Actuals to Formals: Let &lt;i>T&lt;sub>i&lt;/sub>&lt;/i> be the static type of\n&lt;i>a&lt;sub>i&lt;/sub>&lt;/i>, let &lt;i>S&lt;sub>i&lt;/sub>&lt;/i> be the type of &lt;i>p&lt;sub>i&lt;/sub>, 1 &lt;= i &lt;=\nn+k&lt;/i> and let &lt;i>S&lt;sub>q&lt;/sub>&lt;/i> be the type of the named parameter &lt;i>q&lt;/i> of &lt;i>f&lt;/i>.\nIt is a static warning if &lt;i>T&lt;sub>j&lt;/sub>&lt;/i> may not be assigned to &lt;i>S&lt;sub>j&lt;/sub>, 1 &lt;=\nj &lt;= m&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"MAP_VALUE_TYPE_NOT_ASSIGNABLE":{"name":"MAP_VALUE_TYPE_NOT_ASSIGNABLE","qualifiedName":"analyzer/analyzer.StaticWarningCode.MAP_VALUE_TYPE_NOT_ASSIGNABLE","comment":"<p>12.7 Map: A run-time map literal &lt;&lt;i>K&lt;/i>, &lt;i>V&lt;/i>&gt; &lt;i>k&lt;sub>1&lt;/sub>&lt;/i> :\n&lt;i>e&lt;sub>1&lt;/sub>&lt;/i> &hellip; &lt;i>k&lt;sub>n&lt;/sub>&lt;/i> : &lt;i>e&lt;sub>n&lt;/sub>&lt;/i> is evaluated as\nfollows:\n* The operator = is invoked on &lt;i>m&lt;/i> with first argument &lt;i>k&lt;sub>i&lt;/sub>&lt;/i> and second\nargument &lt;i>e&lt;sub>i&lt;/sub>&lt;/i>&lt;i>, 1 &lt;= i &lt;= n&lt;/i></p>\n<p>12.14.2 Binding Actuals to Formals: Let &lt;i>T&lt;sub>i&lt;/sub>&lt;/i> be the static type of\n&lt;i>a&lt;sub>i&lt;/sub>&lt;/i>, let &lt;i>S&lt;sub>i&lt;/sub>&lt;/i> be the type of &lt;i>p&lt;sub>i&lt;/sub>, 1 &lt;= i &lt;=\nn+k&lt;/i> and let &lt;i>S&lt;sub>q&lt;/sub>&lt;/i> be the type of the named parameter &lt;i>q&lt;/i> of &lt;i>f&lt;/i>.\nIt is a static warning if &lt;i>T&lt;sub>j&lt;/sub>&lt;/i> may not be assigned to &lt;i>S&lt;sub>j&lt;/sub>, 1 &lt;=\nj &lt;= m&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"MISMATCHED_GETTER_AND_SETTER_TYPES":{"name":"MISMATCHED_GETTER_AND_SETTER_TYPES","qualifiedName":"analyzer/analyzer.StaticWarningCode.MISMATCHED_GETTER_AND_SETTER_TYPES","comment":"<p>7.3 Setters: It is a static warning if a class has a setter named &lt;i>v=&lt;/i> with argument type\n&lt;i>T&lt;/i> and a getter named &lt;i>v&lt;/i> with return type &lt;i>S&lt;/i>, and &lt;i>T&lt;/i> may not be\nassigned to &lt;i>S&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"MISMATCHED_GETTER_AND_SETTER_TYPES_FROM_SUPERTYPE":{"name":"MISMATCHED_GETTER_AND_SETTER_TYPES_FROM_SUPERTYPE","qualifiedName":"analyzer/analyzer.StaticWarningCode.MISMATCHED_GETTER_AND_SETTER_TYPES_FROM_SUPERTYPE","comment":"<p>7.3 Setters: It is a static warning if a class has a setter named &lt;i>v=&lt;/i> with argument type\n&lt;i>T&lt;/i> and a getter named &lt;i>v&lt;/i> with return type &lt;i>S&lt;/i>, and &lt;i>T&lt;/i> may not be\nassigned to &lt;i>S&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"MIXED_RETURN_TYPES":{"name":"MIXED_RETURN_TYPES","qualifiedName":"analyzer/analyzer.StaticWarningCode.MIXED_RETURN_TYPES","comment":"<p>13.12 Return: It is a static warning if a function contains both one or more return statements\nof the form &lt;i>return;&lt;/i> and one or more return statements of the form &lt;i>return e;&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"NEW_WITH_ABSTRACT_CLASS":{"name":"NEW_WITH_ABSTRACT_CLASS","qualifiedName":"analyzer/analyzer.StaticWarningCode.NEW_WITH_ABSTRACT_CLASS","comment":"<p>12.11.1 New: It is a static warning if &lt;i>q&lt;/i> is a constructor of an abstract class and\n&lt;i>q&lt;/i> is not a factory constructor.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"NEW_WITH_INVALID_TYPE_PARAMETERS":{"name":"NEW_WITH_INVALID_TYPE_PARAMETERS","qualifiedName":"analyzer/analyzer.StaticWarningCode.NEW_WITH_INVALID_TYPE_PARAMETERS","comment":"<p>15.8 Parameterized Types: Any use of a malbounded type gives rise to a static warning.</p>\n<p>@param typeName the name of the type being referenced (&lt;i>S&lt;/i>)\n@param parameterCount the number of type parameters that were declared\n@param argumentCount the number of type arguments provided\n@see CompileTimeErrorCode#CONST<em>WITH</em>INVALID<em>TYPE</em>PARAMETERS\n@see StaticTypeWarningCode#WRONG<em>NUMBER</em>OF<em>TYPE</em>ARGUMENTS</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"NEW_WITH_NON_TYPE":{"name":"NEW_WITH_NON_TYPE","qualifiedName":"analyzer/analyzer.StaticWarningCode.NEW_WITH_NON_TYPE","comment":"<p>12.11.1 New: It is a static warning if &lt;i>T&lt;/i> is not a class accessible in the current scope,\noptionally followed by type arguments.</p>\n<p>@param name the name of the non-type element</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"NEW_WITH_UNDEFINED_CONSTRUCTOR":{"name":"NEW_WITH_UNDEFINED_CONSTRUCTOR","qualifiedName":"analyzer/analyzer.StaticWarningCode.NEW_WITH_UNDEFINED_CONSTRUCTOR","comment":"<p>12.11.1 New: If &lt;i>T&lt;/i> is a class or parameterized type accessible in the current scope then:\n1. If &lt;i>e&lt;/i> is of the form &lt;i>new T.id(a&lt;sub>1&lt;/sub>, &hellip;, a&lt;sub>n&lt;/sub>,\nx&lt;sub>n+1&lt;/sub>: a&lt;sub>n+1&lt;/sub>, &hellip;, x&lt;sub>n+k&lt;/sub>: a&lt;sub>n+k&lt;/sub>)&lt;/i> it is a\nstatic warning if &lt;i>T.id&lt;/i> is not the name of a constructor declared by the type &lt;i>T&lt;/i>.\nIf &lt;i>e&lt;/i> of the form &lt;i>new T(a&lt;sub>1&lt;/sub>, &hellip;, a&lt;sub>n&lt;/sub>, x&lt;sub>n+1&lt;/sub>:\na&lt;sub>n+1&lt;/sub>, &hellip;, x&lt;sub>n+k&lt;/sub>: a&lt;sub>n+kM/sub>)&lt;/i> it is a static warning if the\ntype &lt;i>T&lt;/i> does not declare a constructor with the same name as the declaration of &lt;i>T&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"NEW_WITH_UNDEFINED_CONSTRUCTOR_DEFAULT":{"name":"NEW_WITH_UNDEFINED_CONSTRUCTOR_DEFAULT","qualifiedName":"analyzer/analyzer.StaticWarningCode.NEW_WITH_UNDEFINED_CONSTRUCTOR_DEFAULT","comment":"<p>12.11.1 New: If &lt;i>T&lt;/i> is a class or parameterized type accessible in the current scope then:\n1. If &lt;i>e&lt;/i> is of the form &lt;i>new T.id(a&lt;sub>1&lt;/sub>, &hellip;, a&lt;sub>n&lt;/sub>,\nx&lt;sub>n+1&lt;/sub>: a&lt;sub>n+1&lt;/sub>, &hellip;, x&lt;sub>n+k&lt;/sub>: a&lt;sub>n+k&lt;/sub>)&lt;/i> it is a\nstatic warning if &lt;i>T.id&lt;/i> is not the name of a constructor declared by the type &lt;i>T&lt;/i>.\nIf &lt;i>e&lt;/i> of the form &lt;i>new T(a&lt;sub>1&lt;/sub>, &hellip;, a&lt;sub>n&lt;/sub>, x&lt;sub>n+1&lt;/sub>:\na&lt;sub>n+1&lt;/sub>, &hellip;, x&lt;sub>n+k&lt;/sub>: a&lt;sub>n+kM/sub>)&lt;/i> it is a static warning if the\ntype &lt;i>T&lt;/i> does not declare a constructor with the same name as the declaration of &lt;i>T&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_FIVE_PLUS":{"name":"NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_FIVE_PLUS","qualifiedName":"analyzer/analyzer.StaticWarningCode.NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_FIVE_PLUS","comment":"<p>7.9.1 Inheritance and Overriding: It is a static warning if a non-abstract class inherits an\nabstract method.</p>\n<p>7.10 Superinterfaces: Let &lt;i>C&lt;/i> be a concrete class that does not declare its own\n&lt;i>noSuchMethod()&lt;/i> method. It is a static warning if the implicit interface of &lt;i>C&lt;/i>\nincludes an instance member &lt;i>m&lt;/i> of type &lt;i>F&lt;/i> and &lt;i>C&lt;/i> does not declare or inherit\na corresponding instance member &lt;i>m&lt;/i> of type &lt;i>F'&lt;/i> such that &lt;i>F' &lt;: F&lt;/i>.</p>\n<p>7.4 Abstract Instance Members: It is a static warning if an abstract member is declared or\ninherited in a concrete class unless that member overrides a concrete one.</p>\n<p>@param memberName the name of the first member\n@param memberName the name of the second member\n@param memberName the name of the third member\n@param memberName the name of the fourth member\n@param additionalCount the number of additional missing members that aren't listed</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_FOUR":{"name":"NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_FOUR","qualifiedName":"analyzer/analyzer.StaticWarningCode.NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_FOUR","comment":"<p>7.9.1 Inheritance and Overriding: It is a static warning if a non-abstract class inherits an\nabstract method.</p>\n<p>7.10 Superinterfaces: Let &lt;i>C&lt;/i> be a concrete class that does not declare its own\n&lt;i>noSuchMethod()&lt;/i> method. It is a static warning if the implicit interface of &lt;i>C&lt;/i>\nincludes an instance member &lt;i>m&lt;/i> of type &lt;i>F&lt;/i> and &lt;i>C&lt;/i> does not declare or inherit\na corresponding instance member &lt;i>m&lt;/i> of type &lt;i>F'&lt;/i> such that &lt;i>F' &lt;: F&lt;/i>.</p>\n<p>7.4 Abstract Instance Members: It is a static warning if an abstract member is declared or\ninherited in a concrete class unless that member overrides a concrete one.</p>\n<p>@param memberName the name of the first member\n@param memberName the name of the second member\n@param memberName the name of the third member\n@param memberName the name of the fourth member</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_ONE":{"name":"NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_ONE","qualifiedName":"analyzer/analyzer.StaticWarningCode.NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_ONE","comment":"<p>7.9.1 Inheritance and Overriding: It is a static warning if a non-abstract class inherits an\nabstract method.</p>\n<p>7.10 Superinterfaces: Let &lt;i>C&lt;/i> be a concrete class that does not declare its own\n&lt;i>noSuchMethod()&lt;/i> method. It is a static warning if the implicit interface of &lt;i>C&lt;/i>\nincludes an instance member &lt;i>m&lt;/i> of type &lt;i>F&lt;/i> and &lt;i>C&lt;/i> does not declare or inherit\na corresponding instance member &lt;i>m&lt;/i> of type &lt;i>F'&lt;/i> such that &lt;i>F' &lt;: F&lt;/i>.</p>\n<p>7.4 Abstract Instance Members: It is a static warning if an abstract member is declared or\ninherited in a concrete class unless that member overrides a concrete one.</p>\n<p>@param memberName the name of the member</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_THREE":{"name":"NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_THREE","qualifiedName":"analyzer/analyzer.StaticWarningCode.NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_THREE","comment":"<p>7.9.1 Inheritance and Overriding: It is a static warning if a non-abstract class inherits an\nabstract method.</p>\n<p>7.10 Superinterfaces: Let &lt;i>C&lt;/i> be a concrete class that does not declare its own\n&lt;i>noSuchMethod()&lt;/i> method. It is a static warning if the implicit interface of &lt;i>C&lt;/i>\nincludes an instance member &lt;i>m&lt;/i> of type &lt;i>F&lt;/i> and &lt;i>C&lt;/i> does not declare or inherit\na corresponding instance member &lt;i>m&lt;/i> of type &lt;i>F'&lt;/i> such that &lt;i>F' &lt;: F&lt;/i>.</p>\n<p>7.4 Abstract Instance Members: It is a static warning if an abstract member is declared or\ninherited in a concrete class unless that member overrides a concrete one.</p>\n<p>@param memberName the name of the first member\n@param memberName the name of the second member\n@param memberName the name of the third member</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_TWO":{"name":"NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_TWO","qualifiedName":"analyzer/analyzer.StaticWarningCode.NON_ABSTRACT_CLASS_INHERITS_ABSTRACT_MEMBER_TWO","comment":"<p>7.9.1 Inheritance and Overriding: It is a static warning if a non-abstract class inherits an\nabstract method.</p>\n<p>7.10 Superinterfaces: Let &lt;i>C&lt;/i> be a concrete class that does not declare its own\n&lt;i>noSuchMethod()&lt;/i> method. It is a static warning if the implicit interface of &lt;i>C&lt;/i>\nincludes an instance member &lt;i>m&lt;/i> of type &lt;i>F&lt;/i> and &lt;i>C&lt;/i> does not declare or inherit\na corresponding instance member &lt;i>m&lt;/i> of type &lt;i>F'&lt;/i> such that &lt;i>F' &lt;: F&lt;/i>.</p>\n<p>7.4 Abstract Instance Members: It is a static warning if an abstract member is declared or\ninherited in a concrete class unless that member overrides a concrete one.</p>\n<p>@param memberName the name of the first member\n@param memberName the name of the second member</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"NON_TYPE_IN_CATCH_CLAUSE":{"name":"NON_TYPE_IN_CATCH_CLAUSE","qualifiedName":"analyzer/analyzer.StaticWarningCode.NON_TYPE_IN_CATCH_CLAUSE","comment":"<p>13.11 Try: An on-catch clause of the form &lt;i>on T catch (p&lt;sub>1&lt;/sub>, p&lt;sub>2&lt;/sub>) s&lt;/i> or\n&lt;i>on T s&lt;/i> matches an object &lt;i>o&lt;/i> if the type of &lt;i>o&lt;/i> is a subtype of &lt;i>T&lt;/i>. It\nis a static warning if &lt;i>T&lt;/i> does not denote a type available in the lexical scope of the\ncatch clause.</p>\n<p>@param name the name of the non-type element</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"NON_VOID_RETURN_FOR_OPERATOR":{"name":"NON_VOID_RETURN_FOR_OPERATOR","qualifiedName":"analyzer/analyzer.StaticWarningCode.NON_VOID_RETURN_FOR_OPERATOR","comment":"<p>7.1.1 Operators: It is a static warning if the return type of the user-declared operator = is\nexplicitly declared and not void.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"NON_VOID_RETURN_FOR_SETTER":{"name":"NON_VOID_RETURN_FOR_SETTER","qualifiedName":"analyzer/analyzer.StaticWarningCode.NON_VOID_RETURN_FOR_SETTER","comment":"<p>7.3 Setters: It is a static warning if a setter declares a return type other than void.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"NOT_A_TYPE":{"name":"NOT_A_TYPE","qualifiedName":"analyzer/analyzer.StaticWarningCode.NOT_A_TYPE","comment":"<p>15.1 Static Types: A type &lt;i>T&lt;/i> is malformed iff: * &lt;i>T&lt;/i> has the form &lt;i>id&lt;/i> or the\nform &lt;i>prefix.id&lt;/i>, and in the enclosing lexical scope, the name &lt;i>id&lt;/i> (respectively\n&lt;i>prefix.id&lt;/i>) does not denote a type. * &lt;i>T&lt;/i> denotes a type parameter in the\nenclosing lexical scope, but occurs in the signature or body of a static member. *\n&lt;i>T&lt;/i> is a parameterized type of the form &lt;i>G&lt;S&lt;sub>1&lt;/sub>, .., S&lt;sub>n&lt;/sub>&gt;&lt;/i>,</p>\n<p>Any use of a malformed type gives rise to a static warning.</p>\n<p>@param nonTypeName the name that is not a type</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"NOT_ENOUGH_REQUIRED_ARGUMENTS":{"name":"NOT_ENOUGH_REQUIRED_ARGUMENTS","qualifiedName":"analyzer/analyzer.StaticWarningCode.NOT_ENOUGH_REQUIRED_ARGUMENTS","comment":"<p>12.14.2 Binding Actuals to Formals: It is a static warning if &lt;i>m &lt; h&lt;/i> or if &lt;i>m &gt;\nn&lt;/i>.</p>\n<p>@param requiredCount the expected number of required arguments\n@param argumentCount the actual number of positional arguments given\n@see #EXTRA<em>POSITIONAL</em>ARGUMENTS</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"PART_OF_DIFFERENT_LIBRARY":{"name":"PART_OF_DIFFERENT_LIBRARY","qualifiedName":"analyzer/analyzer.StaticWarningCode.PART_OF_DIFFERENT_LIBRARY","comment":"<p>14.3 Parts: It is a static warning if the referenced part declaration &lt;i>p&lt;/i> names a library\nother than the current library as the library to which &lt;i>p&lt;/i> belongs.</p>\n<p>@param expectedLibraryName the name of expected library name\n@param actualLibraryName the non-matching actual library name from the \"part of\" declaration</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"REDIRECT_TO_INVALID_FUNCTION_TYPE":{"name":"REDIRECT_TO_INVALID_FUNCTION_TYPE","qualifiedName":"analyzer/analyzer.StaticWarningCode.REDIRECT_TO_INVALID_FUNCTION_TYPE","comment":"<p>7.6.2 Factories: It is a static warning if the function type of &lt;i>k'&lt;/i> is not a subtype of\nthe type of &lt;i>k&lt;/i>.</p>\n<p>@param redirectedName the name of the redirected constructor\n@param redirectingName the name of the redirecting constructor</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"REDIRECT_TO_INVALID_RETURN_TYPE":{"name":"REDIRECT_TO_INVALID_RETURN_TYPE","qualifiedName":"analyzer/analyzer.StaticWarningCode.REDIRECT_TO_INVALID_RETURN_TYPE","comment":"<p>7.6.2 Factories: It is a static warning if the function type of &lt;i>k'&lt;/i> is not a subtype of\nthe type of &lt;i>k&lt;/i>.</p>\n<p>@param redirectedName the name of the redirected constructor return type\n@param redirectingName the name of the redirecting constructor return type</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"REDIRECT_TO_MISSING_CONSTRUCTOR":{"name":"REDIRECT_TO_MISSING_CONSTRUCTOR","qualifiedName":"analyzer/analyzer.StaticWarningCode.REDIRECT_TO_MISSING_CONSTRUCTOR","comment":"<p>7.6.2 Factories: It is a static warning if type does not denote a class accessible in the\ncurrent scope; if type does denote such a class &lt;i>C&lt;/i> it is a static warning if the\nreferenced constructor (be it &lt;i>type&lt;/i> or &lt;i>type.id&lt;/i>) is not a constructor of &lt;i>C&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"REDIRECT_TO_NON_CLASS":{"name":"REDIRECT_TO_NON_CLASS","qualifiedName":"analyzer/analyzer.StaticWarningCode.REDIRECT_TO_NON_CLASS","comment":"<p>7.6.2 Factories: It is a static warning if type does not denote a class accessible in the\ncurrent scope; if type does denote such a class &lt;i>C&lt;/i> it is a static warning if the\nreferenced constructor (be it &lt;i>type&lt;/i> or &lt;i>type.id&lt;/i>) is not a constructor of &lt;i>C&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"RETURN_WITHOUT_VALUE":{"name":"RETURN_WITHOUT_VALUE","qualifiedName":"analyzer/analyzer.StaticWarningCode.RETURN_WITHOUT_VALUE","comment":"<p>13.12 Return: Let &lt;i>f&lt;/i> be the function immediately enclosing a return statement of the form\n&lt;i>return;&lt;/i> It is a static warning if both of the following conditions hold:\n&lt;ol>\n<em> &lt;i>f&lt;/i> is not a generative constructor.\n</em> The return type of &lt;i>f&lt;/i> may not be assigned to void.\n&lt;/ol></p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"STATIC_ACCESS_TO_INSTANCE_MEMBER":{"name":"STATIC_ACCESS_TO_INSTANCE_MEMBER","qualifiedName":"analyzer/analyzer.StaticWarningCode.STATIC_ACCESS_TO_INSTANCE_MEMBER","comment":"<p>12.16.3 Static Invocation: It is a static warning if &lt;i>C&lt;/i> does not declare a static method\nor getter &lt;i>m&lt;/i>.</p>\n<p>@param memberName the name of the instance member</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"SWITCH_EXPRESSION_NOT_ASSIGNABLE":{"name":"SWITCH_EXPRESSION_NOT_ASSIGNABLE","qualifiedName":"analyzer/analyzer.StaticWarningCode.SWITCH_EXPRESSION_NOT_ASSIGNABLE","comment":"<p>13.9 Switch: It is a static warning if the type of &lt;i>e&lt;/i> may not be assigned to the type of\n&lt;i>e&lt;sub>k&lt;/sub>&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"TYPE_PARAMETER_REFERENCED_BY_STATIC":{"name":"TYPE_PARAMETER_REFERENCED_BY_STATIC","qualifiedName":"analyzer/analyzer.StaticWarningCode.TYPE_PARAMETER_REFERENCED_BY_STATIC","comment":"<p>10 Generics: However, a type parameter is considered to be a malformed type when referenced by\na static member.</p>\n<p>15.1 Static Types: Any use of a malformed type gives rise to a static warning. A malformed type\nis then interpreted as dynamic by the static type checker and the runtime.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"TYPE_TEST_NON_TYPE":{"name":"TYPE_TEST_NON_TYPE","qualifiedName":"analyzer/analyzer.StaticWarningCode.TYPE_TEST_NON_TYPE","comment":"<p>12.31 Type Test: It is a static warning if &lt;i>T&lt;/i> does not denote a type available in the\ncurrent lexical scope.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"UNDEFINED_CLASS":{"name":"UNDEFINED_CLASS","qualifiedName":"analyzer/analyzer.StaticWarningCode.UNDEFINED_CLASS","comment":"<p>12.16.3 Static Invocation: A static method invocation &lt;i>i&lt;/i> has the form\n&lt;i>C.m(a&lt;sub>1&lt;/sub>, &hellip;, a&lt;sub>n&lt;/sub>, x&lt;sub>n+1&lt;/sub>: a&lt;sub>n+1&lt;/sub>, &hellip;\nx&lt;sub>n+k&lt;/sub>: a&lt;sub>n+k&lt;/sub>)&lt;/i>. It is a static warning if &lt;i>C&lt;/i> does not denote a\nclass in the current scope.</p>\n<p>@param undefinedClassName the name of the undefined class</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"UNDEFINED_CLASS_BOOLEAN":{"name":"UNDEFINED_CLASS_BOOLEAN","qualifiedName":"analyzer/analyzer.StaticWarningCode.UNDEFINED_CLASS_BOOLEAN","comment":"<p>Same as <a>analyzer/analyzer.StaticWarningCode.UNDEFINED_CLASS</a>, but to catch using \"boolean\" instead of \"bool\".</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"UNDEFINED_GETTER":{"name":"UNDEFINED_GETTER","qualifiedName":"analyzer/analyzer.StaticWarningCode.UNDEFINED_GETTER","comment":"<p>12.17 Getter Invocation: It is a static warning if there is no class &lt;i>C&lt;/i> in the enclosing\nlexical scope of &lt;i>i&lt;/i>, or if &lt;i>C&lt;/i> does not declare, implicitly or explicitly, a getter\nnamed &lt;i>m&lt;/i>.</p>\n<p>@param getterName the name of the getter\n@param enclosingType the name of the enclosing type where the getter is being looked for</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"UNDEFINED_IDENTIFIER":{"name":"UNDEFINED_IDENTIFIER","qualifiedName":"analyzer/analyzer.StaticWarningCode.UNDEFINED_IDENTIFIER","comment":"<p>12.30 Identifier Reference: It is as static warning if an identifier expression of the form\n&lt;i>id&lt;/i> occurs inside a top level or static function (be it function, method, getter, or\nsetter) or variable initializer and there is no declaration &lt;i>d&lt;/i> with name &lt;i>id&lt;/i> in the\nlexical scope enclosing the expression.</p>\n<p>@param name the name of the identifier</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"UNDEFINED_NAMED_PARAMETER":{"name":"UNDEFINED_NAMED_PARAMETER","qualifiedName":"analyzer/analyzer.StaticWarningCode.UNDEFINED_NAMED_PARAMETER","comment":"<p>12.14.2 Binding Actuals to Formals: Furthermore, each &lt;i>q&lt;sub>i&lt;/sub>&lt;/i>, &lt;i>1&lt;=i&lt;=l&lt;/i>,\nmust have a corresponding named parameter in the set {&lt;i>p&lt;sub>n+1&lt;/sub>&lt;/i> &hellip;\n&lt;i>p&lt;sub>n+k&lt;/sub>&lt;/i>} or a static warning occurs.</p>\n<p>@param name the name of the requested named parameter</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"UNDEFINED_SETTER":{"name":"UNDEFINED_SETTER","qualifiedName":"analyzer/analyzer.StaticWarningCode.UNDEFINED_SETTER","comment":"<p>12.18 Assignment: It is as static warning if an assignment of the form &lt;i>v = e&lt;/i> occurs\ninside a top level or static function (be it function, method, getter, or setter) or variable\ninitializer and there is no declaration &lt;i>d&lt;/i> with name &lt;i>v=&lt;/i> in the lexical scope\nenclosing the assignment.</p>\n<p>12.18 Assignment: It is a static warning if there is no class &lt;i>C&lt;/i> in the enclosing lexical\nscope of the assignment, or if &lt;i>C&lt;/i> does not declare, implicitly or explicitly, a setter\n&lt;i>v=&lt;/i>.</p>\n<p>@param setterName the name of the getter\n@param enclosingType the name of the enclosing type where the setter is being looked for</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"UNDEFINED_STATIC_METHOD_OR_GETTER":{"name":"UNDEFINED_STATIC_METHOD_OR_GETTER","qualifiedName":"analyzer/analyzer.StaticWarningCode.UNDEFINED_STATIC_METHOD_OR_GETTER","comment":"<p>12.16.3 Static Invocation: It is a static warning if &lt;i>C&lt;/i> does not declare a static method\nor getter &lt;i>m&lt;/i>.</p>\n<p>@param methodName the name of the method\n@param enclosingType the name of the enclosing type where the method is being looked for</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"VOID_RETURN_FOR_GETTER":{"name":"VOID_RETURN_FOR_GETTER","qualifiedName":"analyzer/analyzer.StaticWarningCode.VOID_RETURN_FOR_GETTER","comment":"<p>7.2 Getters: It is a static warning if the return type of a getter is void.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}],"annotations":[]},"correction":{"name":"correction","qualifiedName":"analyzer/analyzer.StaticWarningCode.correction","comment":"<p>The template used to create the correction to be displayed for this error, or <code>null</code> if\nthere is no correction information for this error.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"message":{"name":"message","qualifiedName":"analyzer/analyzer.StaticWarningCode.message","comment":"<p>The template used to create the message to be displayed for this error.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"values":{"name":"values","qualifiedName":"analyzer/analyzer.StaticWarningCode.values","comment":"","final":false,"static":true,"constant":true,"type":[{"outer":"dart-core.List","inner":[{"outer":"analyzer/analyzer.StaticWarningCode","inner":[]}]}],"annotations":[]}},"inheritedVariables":{"name":{"name":"name","qualifiedName":"analyzer/analyzer.Enum.name","comment":"<p>The name of this enum constant, as declared in the enum declaration.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"ordinal":{"name":"ordinal","qualifiedName":"analyzer/analyzer.Enum.ordinal","comment":"<p>The position in the enum declaration.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.int","inner":[]}],"annotations":[]}},"methods":{"setters":{},"getters":{"errorSeverity":{"name":"errorSeverity","qualifiedName":"analyzer/analyzer.StaticWarningCode.errorSeverity","comment":"<p>Return the severity of this error.</p>\n<p>@return the severity of this error</p>","commentFrom":"analyzer.ErrorCode.errorSeverity","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/analyzer.ErrorSeverity","inner":[]}],"parameters":{},"annotations":[{"name":"analyzer/dart-core.override","parameters":[]}]},"type":{"name":"type","qualifiedName":"analyzer/analyzer.StaticWarningCode.type","comment":"<p>Return the type of the error.</p>\n<p>@return the type of the error</p>","commentFrom":"analyzer.ErrorCode.type","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/analyzer.ErrorType","inner":[]}],"parameters":{},"annotations":[{"name":"analyzer/dart-core.override","parameters":[]}]}},"constructors":{"con1":{"name":"con1","qualifiedName":"analyzer/analyzer.StaticWarningCode.StaticWarningCode-con1","comment":"<p>Initialize a newly created error code to have the given message.</p>\n<p>@param message the message template used to create the message to be displayed for the error</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":true,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"ordinal":{"name":"ordinal","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"con2":{"name":"con2","qualifiedName":"analyzer/analyzer.StaticWarningCode.StaticWarningCode-con2","comment":"<p>Initialize a newly created error code to have the given message and correction.</p>\n<p>@param message the template used to create the message to be displayed for the error\n@param correction the template used to create the correction to be displayed for the error</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":true,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"ordinal":{"name":"ordinal","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"correction":{"name":"correction","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{},"methods":{}},"inheritedMethods":{"setters":{},"getters":{"correction":{"name":"correction","qualifiedName":"analyzer/analyzer.StaticWarningCode.correction","comment":"<p>Return the template used to create the correction to be displayed for this error, or\n<code>null</code> if there is no correction information for this error. The correction should\nindicate how the user can fix the error.</p>\n<p>@return the template used to create the correction to be displayed for this error</p>","commentFrom":"","inheritedFrom":"analyzer.ErrorCode.correction","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"errorSeverity":{"name":"errorSeverity","qualifiedName":"analyzer/analyzer.StaticWarningCode.errorSeverity","comment":"<p>Return the severity of this error.</p>\n<p>@return the severity of this error</p>","commentFrom":"","inheritedFrom":"analyzer.ErrorCode.errorSeverity","static":false,"abstract":true,"constant":false,"return":[{"outer":"analyzer/analyzer.ErrorSeverity","inner":[]}],"parameters":{},"annotations":[]},"hashCode":{"name":"hashCode","qualifiedName":"analyzer/analyzer.StaticWarningCode.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>analyzer/analyzer.StaticWarningCode.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"message":{"name":"message","qualifiedName":"analyzer/analyzer.StaticWarningCode.message","comment":"<p>Return the template used to create the message to be displayed for this error. The message\nshould indicate what is wrong and why it is wrong.</p>\n<p>@return the template used to create the message to be displayed for this error</p>","commentFrom":"","inheritedFrom":"analyzer.ErrorCode.message","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"analyzer/analyzer.StaticWarningCode.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]},"type":{"name":"type","qualifiedName":"analyzer/analyzer.StaticWarningCode.type","comment":"<p>Return the type of the error.</p>\n<p>@return the type of the error</p>","commentFrom":"","inheritedFrom":"analyzer.ErrorCode.type","static":false,"abstract":true,"constant":false,"return":[{"outer":"analyzer/analyzer.ErrorType","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"analyzer/analyzer.StaticWarningCode.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>analyzer/analyzer.StaticWarningCode.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>analyzer/analyzer.StaticWarningCode.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"compareTo":{"name":"compareTo","qualifiedName":"analyzer/analyzer.StaticWarningCode.compareTo","comment":"<p>Compares this object to another <a>dart-core.Comparable</a></p>\n<p>Returns a value like a <a>dart-core.Comparator</a> when comparing <code>this</code> to <a>analyzer/analyzer.StaticWarningCode.compareTo.other</a>.\nThat is, it returns a negative integer if <code>this</code> is ordered before <a>analyzer/analyzer.StaticWarningCode.compareTo.other</a>,\na positive integer if <code>this</code> is ordered after <a>analyzer/analyzer.StaticWarningCode.compareTo.other</a>,\nand zero if <code>this</code> and <a>analyzer/analyzer.StaticWarningCode.compareTo.other</a> are ordered together.</p>\n<p>The <a>analyzer/analyzer.StaticWarningCode.compareTo.other</a> argument must be a value that is comparable to this object.</p>","commentFrom":"dart-core.Comparable.compareTo","inheritedFrom":"analyzer.Enum.compareTo","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.Enum.E","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"analyzer/analyzer.StaticWarningCode.noSuchMethod","comment":"<p><a>analyzer/analyzer.StaticWarningCode.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>analyzer/analyzer.StaticWarningCode.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>analyzer/analyzer.StaticWarningCode.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>analyzer/analyzer.StaticWarningCode.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"analyzer/analyzer.StaticWarningCode.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}