{"name":"IndexExpression","qualifiedName":"analyzer/analyzer.IndexExpression","comment":"<p>Instances of the class <code>IndexExpression</code> represent an index expression.</p><pre>\nindexExpression ::=\n    [Expression] '[' [Expression] ']'\n</pre>","isAbstract":false,"superclass":"analyzer/analyzer.Expression","implements":[],"subclass":[],"variables":{"auxiliaryElements":{"name":"auxiliaryElements","qualifiedName":"analyzer/analyzer.IndexExpression.auxiliaryElements","comment":"<p>If this expression is both in a getter and setter context, the <a>analyzer/engine-element.AuxiliaryElements</a> will\nbe set to hold onto the static and propagated information. The auxiliary element will hold onto\nthe elements from the getter context.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"analyzer/engine-element.AuxiliaryElements","inner":[]}],"annotations":[]},"period":{"name":"period","qualifiedName":"analyzer/analyzer.IndexExpression.period","comment":"<p>The period (\"..\") before a cascaded index expression, or <code>null</code> if this index expression\nis not part of a cascade expression.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"analyzer/engine-scanner.Token","inner":[]}],"annotations":[]}},"inheritedVariables":{"propagatedType":{"name":"propagatedType","qualifiedName":"analyzer/analyzer.Expression.propagatedType","comment":"<p>The propagated type of this expression, or <code>null</code> if type propagation has not been\nperformed on the AST structure.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"analyzer/engine-element.DartType","inner":[]}],"annotations":[]},"staticType":{"name":"staticType","qualifiedName":"analyzer/analyzer.Expression.staticType","comment":"<p>The static type of this expression, or <code>null</code> if the AST structure has not been resolved.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"analyzer/engine-element.DartType","inner":[]}],"annotations":[]}},"methods":{"setters":{"index=":{"name":"index=","qualifiedName":"analyzer/analyzer.IndexExpression.index=","comment":"<p>Set the expression used to compute the index to the given expression.</p>\n<p>@param expression the expression used to compute the index</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"expression":{"name":"expression","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.Expression","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"leftBracket=":{"name":"leftBracket=","qualifiedName":"analyzer/analyzer.IndexExpression.leftBracket=","comment":"<p>Set the left square bracket to the given token.</p>\n<p>@param bracket the left square bracket</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"bracket":{"name":"bracket","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/engine-scanner.Token","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"propagatedElement=":{"name":"propagatedElement=","qualifiedName":"analyzer/analyzer.IndexExpression.propagatedElement=","comment":"<p>Set the element associated with the operator based on the propagated type of the target to the\ngiven element.</p>\n<p>@param element the element to be associated with this operator</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/engine-element.MethodElement","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"rightBracket=":{"name":"rightBracket=","qualifiedName":"analyzer/analyzer.IndexExpression.rightBracket=","comment":"<p>Set the right square bracket to the given token.</p>\n<p>@param bracket the right square bracket</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"bracket":{"name":"bracket","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/engine-scanner.Token","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"staticElement=":{"name":"staticElement=","qualifiedName":"analyzer/analyzer.IndexExpression.staticElement=","comment":"<p>Set the element associated with the operator based on the static type of the target to the\ngiven element.</p>\n<p>@param element the static element to be associated with the operator</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/engine-element.MethodElement","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"target=":{"name":"target=","qualifiedName":"analyzer/analyzer.IndexExpression.target=","comment":"<p>Set the expression used to compute the object being indexed to the given expression.</p>\n<p>@param expression the expression used to compute the object being indexed</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"expression":{"name":"expression","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.Expression","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"getters":{"beginToken":{"name":"beginToken","qualifiedName":"analyzer/analyzer.IndexExpression.beginToken","comment":"<p>Return the first token included in this node's source range.</p>\n<p>@return the first token included in this node's source range</p>","commentFrom":"analyzer.AstNode.beginToken","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/engine-scanner.Token","inner":[]}],"parameters":{},"annotations":[{"name":"analyzer/dart-core.override","parameters":[]}]},"bestElement":{"name":"bestElement","qualifiedName":"analyzer/analyzer.IndexExpression.bestElement","comment":"<p>Return the best element available for this operator. If resolution was able to find a better\nelement based on type propagation, that element will be returned. Otherwise, the element found\nusing the result of static analysis will be returned. If resolution has not been performed,\nthen <code>null</code> will be returned.</p>\n<p>@return the best element available for this operator</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/engine-element.MethodElement","inner":[]}],"parameters":{},"annotations":[]},"endToken":{"name":"endToken","qualifiedName":"analyzer/analyzer.IndexExpression.endToken","comment":"<p>Return the last token included in this node's source range.</p>\n<p>@return the last token included in this node's source range</p>","commentFrom":"analyzer.AstNode.endToken","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/engine-scanner.Token","inner":[]}],"parameters":{},"annotations":[{"name":"analyzer/dart-core.override","parameters":[]}]},"index":{"name":"index","qualifiedName":"analyzer/analyzer.IndexExpression.index","comment":"<p>Return the expression used to compute the index.</p>\n<p>@return the expression used to compute the index</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/analyzer.Expression","inner":[]}],"parameters":{},"annotations":[]},"isAssignable":{"name":"isAssignable","qualifiedName":"analyzer/analyzer.IndexExpression.isAssignable","comment":"<p>Return <code>true</code> if this expression is syntactically valid for the LHS of an\n<a>analyzer/analyzer.AssignmentExpression</a>.</p>\n<p>@return <code>true</code> if this expression matches the <code>assignableExpression</code> production</p>","commentFrom":"analyzer.Expression.isAssignable","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[{"name":"analyzer/dart-core.override","parameters":[]}]},"isCascaded":{"name":"isCascaded","qualifiedName":"analyzer/analyzer.IndexExpression.isCascaded","comment":"<p>Return <code>true</code> if this expression is cascaded. If it is, then the target of this\nexpression is not stored locally but is stored in the nearest ancestor that is a\n<a>analyzer/analyzer.CascadeExpression</a>.</p>\n<p>@return <code>true</code> if this expression is cascaded</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"leftBracket":{"name":"leftBracket","qualifiedName":"analyzer/analyzer.IndexExpression.leftBracket","comment":"<p>Return the left square bracket.</p>\n<p>@return the left square bracket</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/engine-scanner.Token","inner":[]}],"parameters":{},"annotations":[]},"precedence":{"name":"precedence","qualifiedName":"analyzer/analyzer.IndexExpression.precedence","comment":"<p>Return the precedence of this expression. The precedence is a positive integer value that\ndefines how the source code is parsed into an AST. For example <code>a * b + c</code> is parsed as\n<code>(a * b) + c</code> because the precedence of <code>*</code> is greater than the precedence of\n<code>+</code>.</p>\n<p>You should not assume that returned values will stay the same, they might change as result of\nspecification change. Only relative order should be used.</p>\n<p>@return the precedence of this expression</p>","commentFrom":"analyzer.Expression.precedence","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[{"name":"analyzer/dart-core.override","parameters":[]}]},"propagatedElement":{"name":"propagatedElement","qualifiedName":"analyzer/analyzer.IndexExpression.propagatedElement","comment":"<p>Return the element associated with the operator based on the propagated type of the target, or\n<code>null</code> if the AST structure has not been resolved or if the operator could not be\nresolved. One example of the latter case is an operator that is not defined for the type of the\ntarget.</p>\n<p>@return the element associated with this operator</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/engine-element.MethodElement","inner":[]}],"parameters":{},"annotations":[]},"propagatedParameterElementForIndex":{"name":"propagatedParameterElementForIndex","qualifiedName":"analyzer/analyzer.IndexExpression.propagatedParameterElementForIndex","comment":"<p>If the AST structure has been resolved, and the function being invoked is known based on\npropagated type information, then return the parameter element representing the parameter to\nwhich the value of the index expression will be bound. Otherwise, return <code>null</code>.</p>\n<p>This method is only intended to be used by Expression#getPropagatedParameterElement.</p>\n<p>@return the parameter element representing the parameter to which the value of the index</p>\n<pre><code>    expression will be bound\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/engine-element.ParameterElement","inner":[]}],"parameters":{},"annotations":[]},"realTarget":{"name":"realTarget","qualifiedName":"analyzer/analyzer.IndexExpression.realTarget","comment":"<p>Return the expression used to compute the object being indexed. If this index expression is not\npart of a cascade expression, then this is the same as getTarget. If this index\nexpression is part of a cascade expression, then the target expression stored with the cascade\nexpression is returned.</p>\n<p>@return the expression used to compute the object being indexed\n@see #getTarget()</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/analyzer.Expression","inner":[]}],"parameters":{},"annotations":[]},"rightBracket":{"name":"rightBracket","qualifiedName":"analyzer/analyzer.IndexExpression.rightBracket","comment":"<p>Return the right square bracket.</p>\n<p>@return the right square bracket</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/engine-scanner.Token","inner":[]}],"parameters":{},"annotations":[]},"staticElement":{"name":"staticElement","qualifiedName":"analyzer/analyzer.IndexExpression.staticElement","comment":"<p>Return the element associated with the operator based on the static type of the target, or\n<code>null</code> if the AST structure has not been resolved or if the operator could not be\nresolved. One example of the latter case is an operator that is not defined for the type of the\ntarget.</p>\n<p>@return the element associated with the operator</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/engine-element.MethodElement","inner":[]}],"parameters":{},"annotations":[]},"staticParameterElementForIndex":{"name":"staticParameterElementForIndex","qualifiedName":"analyzer/analyzer.IndexExpression.staticParameterElementForIndex","comment":"<p>If the AST structure has been resolved, and the function being invoked is known based on static\ntype information, then return the parameter element representing the parameter to which the\nvalue of the index expression will be bound. Otherwise, return <code>null</code>.</p>\n<p>This method is only intended to be used by Expression#getStaticParameterElement.</p>\n<p>@return the parameter element representing the parameter to which the value of the index</p>\n<pre><code>    expression will be bound\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/engine-element.ParameterElement","inner":[]}],"parameters":{},"annotations":[]},"target":{"name":"target","qualifiedName":"analyzer/analyzer.IndexExpression.target","comment":"<p>Return the expression used to compute the object being indexed, or <code>null</code> if this index\nexpression is part of a cascade expression.</p>\n<p>@return the expression used to compute the object being indexed\n@see #getRealTarget()</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/analyzer.Expression","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{"forCascade":{"name":"forCascade","qualifiedName":"analyzer/analyzer.IndexExpression.IndexExpression-forCascade","comment":"<p>Initialize a newly created index expression.</p>\n<p>@param period the period (\"..\") before a cascaded index expression\n@param leftBracket the left square bracket\n@param index the expression used to compute the index\n@param rightBracket the right square bracket</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"period":{"name":"period","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/engine-scanner.Token","inner":[]}],"value":null,"annotations":[]},"leftBracket":{"name":"leftBracket","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/engine-scanner.Token","inner":[]}],"value":null,"annotations":[]},"index":{"name":"index","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.Expression","inner":[]}],"value":null,"annotations":[]},"rightBracket":{"name":"rightBracket","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/engine-scanner.Token","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"forTarget":{"name":"forTarget","qualifiedName":"analyzer/analyzer.IndexExpression.IndexExpression-forTarget","comment":"<p>Initialize a newly created index expression.</p>\n<p>@param target the expression used to compute the object being indexed\n@param leftBracket the left square bracket\n@param index the expression used to compute the index\n@param rightBracket the right square bracket</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"target":{"name":"target","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.Expression","inner":[]}],"value":null,"annotations":[]},"leftBracket":{"name":"leftBracket","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/engine-scanner.Token","inner":[]}],"value":null,"annotations":[]},"index":{"name":"index","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.Expression","inner":[]}],"value":null,"annotations":[]},"rightBracket":{"name":"rightBracket","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/engine-scanner.Token","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{},"methods":{"accept":{"name":"accept","qualifiedName":"analyzer/analyzer.IndexExpression.accept","comment":"<p>Use the given visitor to visit this node.</p>\n<p>@param visitor the visitor that will visit this node\n@return the value returned by the visitor as a result of visiting this node</p>","commentFrom":"analyzer.AstNode.accept","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"visitor":{"name":"visitor","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.AstVisitor","inner":[]}],"value":null,"annotations":[]}},"annotations":[{"name":"analyzer/dart-core.override","parameters":[]}]},"inGetterContext":{"name":"inGetterContext","qualifiedName":"analyzer/analyzer.IndexExpression.inGetterContext","comment":"<p>Return <code>true</code> if this expression is computing a right-hand value.</p>\n<p>Note that <a>analyzer/analyzer.IndexExpression.inGetterContext</a> and <a>analyzer/analyzer.IndexExpression.inSetterContext</a> are not opposites, nor are\nthey mutually exclusive. In other words, it is possible for both methods to return <code>true</code>\nwhen invoked on the same node.</p>\n<p>@return <code>true</code> if this expression is in a context where the operator '' will be invoked</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"inSetterContext":{"name":"inSetterContext","qualifiedName":"analyzer/analyzer.IndexExpression.inSetterContext","comment":"<p>Return <code>true</code> if this expression is computing a left-hand value.</p>\n<p>Note that <a>analyzer/analyzer.IndexExpression.inGetterContext</a> and <a>analyzer/analyzer.IndexExpression.inSetterContext</a> are not opposites, nor are\nthey mutually exclusive. In other words, it is possible for both methods to return <code>true</code>\nwhen invoked on the same node.</p>\n<p>@return <code>true</code> if this expression is in a context where the operator '=' will be</p>\n<pre><code>    invoked\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"visitChildren":{"name":"visitChildren","qualifiedName":"analyzer/analyzer.IndexExpression.visitChildren","comment":"<p>Use the given visitor to visit all of the children of this node. The children will be visited\nin source order.</p>\n<p>@param visitor the visitor that will be used to visit the children of this node</p>","commentFrom":"analyzer.AstNode.visitChildren","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"visitor":{"name":"visitor","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.AstVisitor","inner":[]}],"value":null,"annotations":[]}},"annotations":[{"name":"analyzer/dart-core.override","parameters":[]}]}}},"inheritedMethods":{"setters":{"parent=":{"name":"parent=","qualifiedName":"analyzer/analyzer.IndexExpression.parent=","comment":"<p>Set the parent of this node to the given node.</p>\n<p>@param newParent the node that is to be made the parent of this node</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.parent=","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"newParent":{"name":"newParent","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.AstNode","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"getters":{"beginToken":{"name":"beginToken","qualifiedName":"analyzer/analyzer.IndexExpression.beginToken","comment":"<p>Return the first token included in this node's source range.</p>\n<p>@return the first token included in this node's source range</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.beginToken","static":false,"abstract":true,"constant":false,"return":[{"outer":"analyzer/engine-scanner.Token","inner":[]}],"parameters":{},"annotations":[]},"bestParameterElement":{"name":"bestParameterElement","qualifiedName":"analyzer/analyzer.IndexExpression.bestParameterElement","comment":"<p>Return the best parameter element information available for this expression. If type\npropagation was able to find a better parameter element than static analysis, that type will be\nreturned. Otherwise, the result of static analysis will be returned.</p>\n<p>@return the parameter element representing the parameter to which the value of this expression</p>\n<pre><code>    will be bound\n</code></pre>","commentFrom":"","inheritedFrom":"analyzer.Expression.bestParameterElement","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/engine-element.ParameterElement","inner":[]}],"parameters":{},"annotations":[]},"bestType":{"name":"bestType","qualifiedName":"analyzer/analyzer.IndexExpression.bestType","comment":"<p>Return the best type information available for this expression. If type propagation was able to\nfind a better type than static analysis, that type will be returned. Otherwise, the result of\nstatic analysis will be returned. If no type analysis has been performed, then the type\n'dynamic' will be returned.</p>\n<p>@return the best type information available for this expression</p>","commentFrom":"","inheritedFrom":"analyzer.Expression.bestType","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/engine-element.DartType","inner":[]}],"parameters":{},"annotations":[]},"end":{"name":"end","qualifiedName":"analyzer/analyzer.IndexExpression.end","comment":"<p>Return the offset of the character immediately following the last character of this node's\nsource range. This is equivalent to <code>node.getOffset() + node.getLength()</code>. For a\ncompilation unit this will be equal to the length of the unit's source. For synthetic nodes\nthis will be equivalent to the node's offset (because the length is zero (0) by definition).</p>\n<p>@return the offset of the character just past the node's source range</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.end","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"endToken":{"name":"endToken","qualifiedName":"analyzer/analyzer.IndexExpression.endToken","comment":"<p>Return the last token included in this node's source range.</p>\n<p>@return the last token included in this node's source range</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.endToken","static":false,"abstract":true,"constant":false,"return":[{"outer":"analyzer/engine-scanner.Token","inner":[]}],"parameters":{},"annotations":[]},"hashCode":{"name":"hashCode","qualifiedName":"analyzer/analyzer.IndexExpression.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>analyzer/analyzer.IndexExpression.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"isAssignable":{"name":"isAssignable","qualifiedName":"analyzer/analyzer.IndexExpression.isAssignable","comment":"<p>Return <code>true</code> if this expression is syntactically valid for the LHS of an\n<a>analyzer/analyzer.AssignmentExpression</a>.</p>\n<p>@return <code>true</code> if this expression matches the <code>assignableExpression</code> production</p>","commentFrom":"","inheritedFrom":"analyzer.Expression.isAssignable","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isSynthetic":{"name":"isSynthetic","qualifiedName":"analyzer/analyzer.IndexExpression.isSynthetic","comment":"<p>Return <code>true</code> if this node is a synthetic node. A synthetic node is a node that was\nintroduced by the parser in order to recover from an error in the code. Synthetic nodes always\nhave a length of zero (<code>0</code>).</p>\n<p>@return <code>true</code> if this node is a synthetic node</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.isSynthetic","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"length":{"name":"length","qualifiedName":"analyzer/analyzer.IndexExpression.length","comment":"<p>Return the number of characters in the node's source range.</p>\n<p>@return the number of characters in the node's source range</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.length","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"offset":{"name":"offset","qualifiedName":"analyzer/analyzer.IndexExpression.offset","comment":"<p>Return the offset from the beginning of the file to the first character in the node's source\nrange.</p>\n<p>@return the offset from the beginning of the file to the first character in the node's source</p>\n<pre><code>    range\n</code></pre>","commentFrom":"","inheritedFrom":"analyzer.AstNode.offset","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"parent":{"name":"parent","qualifiedName":"analyzer/analyzer.IndexExpression.parent","comment":"<p>Return this node's parent node, or <code>null</code> if this node is the root of an AST structure.</p>\n<p>Note that the relationship between an AST node and its parent node may change over the lifetime\nof a node.</p>\n<p>@return the parent of this node, or <code>null</code> if none</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.parent","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/analyzer.AstNode","inner":[]}],"parameters":{},"annotations":[]},"precedence":{"name":"precedence","qualifiedName":"analyzer/analyzer.IndexExpression.precedence","comment":"<p>Return the precedence of this expression. The precedence is a positive integer value that\ndefines how the source code is parsed into an AST. For example <code>a * b + c</code> is parsed as\n<code>(a * b) + c</code> because the precedence of <code>*</code> is greater than the precedence of\n<code>+</code>.</p>\n<p>You should not assume that returned values will stay the same, they might change as result of\nspecification change. Only relative order should be used.</p>\n<p>@return the precedence of this expression</p>","commentFrom":"","inheritedFrom":"analyzer.Expression.precedence","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"propagatedParameterElement":{"name":"propagatedParameterElement","qualifiedName":"analyzer/analyzer.IndexExpression.propagatedParameterElement","comment":"<p>If this expression is an argument to an invocation, and the AST structure has been resolved,\nand the function being invoked is known based on propagated type information, and this\nexpression corresponds to one of the parameters of the function being invoked, then return the\nparameter element representing the parameter to which the value of this expression will be\nbound. Otherwise, return <code>null</code>.</p>\n<p>@return the parameter element representing the parameter to which the value of this expression</p>\n<pre><code>    will be bound\n</code></pre>","commentFrom":"","inheritedFrom":"analyzer.Expression.propagatedParameterElement","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/engine-element.ParameterElement","inner":[]}],"parameters":{},"annotations":[]},"root":{"name":"root","qualifiedName":"analyzer/analyzer.IndexExpression.root","comment":"<p>Return the node at the root of this node's AST structure. Note that this method's performance\nis linear with respect to the depth of the node in the AST structure (O(depth)).</p>\n<p>@return the node at the root of this node's AST structure</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.root","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/analyzer.AstNode","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"analyzer/analyzer.IndexExpression.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]},"staticParameterElement":{"name":"staticParameterElement","qualifiedName":"analyzer/analyzer.IndexExpression.staticParameterElement","comment":"<p>If this expression is an argument to an invocation, and the AST structure has been resolved,\nand the function being invoked is known based on static type information, and this expression\ncorresponds to one of the parameters of the function being invoked, then return the parameter\nelement representing the parameter to which the value of this expression will be bound.\nOtherwise, return <code>null</code>.</p>\n<p>@return the parameter element representing the parameter to which the value of this expression</p>\n<pre><code>    will be bound\n</code></pre>","commentFrom":"","inheritedFrom":"analyzer.Expression.staticParameterElement","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/engine-element.ParameterElement","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"analyzer/analyzer.IndexExpression.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>analyzer/analyzer.IndexExpression.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>analyzer/analyzer.IndexExpression.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"accept":{"name":"accept","qualifiedName":"analyzer/analyzer.IndexExpression.accept","comment":"<p>Use the given visitor to visit this node.</p>\n<p>@param visitor the visitor that will visit this node\n@return the value returned by the visitor as a result of visiting this node</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.accept","static":false,"abstract":true,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"visitor":{"name":"visitor","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.AstVisitor","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"becomeParentOf":{"name":"becomeParentOf","qualifiedName":"analyzer/analyzer.IndexExpression.becomeParentOf","comment":"<p>Make this node the parent of the given child node.</p>\n<p>@param child the node that will become a child of this node\n@return the node that was made a child of this node</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.becomeParentOf","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/analyzer.AstNode","inner":[]}],"parameters":{"child":{"name":"child","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.AstNode","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"getAncestor":{"name":"getAncestor","qualifiedName":"analyzer/analyzer.IndexExpression.getAncestor","comment":"<p>Return the node of the given class that most immediately encloses this node, or <code>null</code> if\nthere is no enclosing node of the given class.</p>\n<p>@param nodeClass the class of the node to be returned\n@return the node of the given type that encloses this node</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.getAncestor","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/analyzer.AstNode","inner":[]}],"parameters":{"predicate":{"name":"predicate","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/java-engine.Predicate","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"getProperty":{"name":"getProperty","qualifiedName":"analyzer/analyzer.IndexExpression.getProperty","comment":"<p>Return the value of the property with the given name, or <code>null</code> if this node does not\nhave a property with the given name.</p>\n<p>@return the value of the property with the given name</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.getProperty","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Object","inner":[]}],"parameters":{"propertyName":{"name":"propertyName","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"analyzer/analyzer.IndexExpression.noSuchMethod","comment":"<p><a>analyzer/analyzer.IndexExpression.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>analyzer/analyzer.IndexExpression.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>analyzer/analyzer.IndexExpression.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>analyzer/analyzer.IndexExpression.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"safelyVisitChild":{"name":"safelyVisitChild","qualifiedName":"analyzer/analyzer.IndexExpression.safelyVisitChild","comment":"<p>If the given child is not <code>null</code>, use the given visitor to visit it.</p>\n<p>@param child the child to be visited\n@param visitor the visitor that will be used to visit the child</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.safelyVisitChild","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"child":{"name":"child","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.AstNode","inner":[]}],"value":null,"annotations":[]},"visitor":{"name":"visitor","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.AstVisitor","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"setProperty":{"name":"setProperty","qualifiedName":"analyzer/analyzer.IndexExpression.setProperty","comment":"<p>Set the value of the property with the given name to the given value. If the value is\n<code>null</code>, the property will effectively be removed.</p>\n<p>@param propertyName the name of the property whose value is to be set\n@param propertyValue the new value of the property</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.setProperty","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"propertyName":{"name":"propertyName","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"propertyValue":{"name":"propertyValue","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toSource":{"name":"toSource","qualifiedName":"analyzer/analyzer.IndexExpression.toSource","comment":"<p>Return a textual description of this node in a form approximating valid source. The returned\nstring will not be valid source primarily in the case where the node itself is not well-formed.</p>\n<p>@return the source code equivalent of this node</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.toSource","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"toString":{"name":"toString","qualifiedName":"analyzer/analyzer.IndexExpression.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"dart-core.Object.toString","inheritedFrom":"analyzer.AstNode.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[{"name":"analyzer/dart-core.override","parameters":[]}]},"visitChildren":{"name":"visitChildren","qualifiedName":"analyzer/analyzer.IndexExpression.visitChildren","comment":"<p>Use the given visitor to visit all of the children of this node. The children will be visited\nin source order.</p>\n<p>@param visitor the visitor that will be used to visit the children of this node</p>","commentFrom":"","inheritedFrom":"analyzer.AstNode.visitChildren","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"visitor":{"name":"visitor","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.AstVisitor","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}}},"annotations":[],"generics":{}}