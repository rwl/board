{"name":"CompileTimeErrorCode","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode","comment":"<p>The enumeration <code>CompileTimeErrorCode</code> defines the error codes used for compile time\nerrors. The convention for this class is for the name of the error code to indicate the problem\nthat caused the error to be generated and for the error message to explain what is wrong and,\nwhen appropriate, how the problem can be corrected.</p>","isAbstract":false,"superclass":"analyzer/analyzer.Enum","implements":["analyzer/analyzer.ErrorCode"],"subclass":[],"variables":{"AMBIGUOUS_EXPORT":{"name":"AMBIGUOUS_EXPORT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.AMBIGUOUS_EXPORT","comment":"<p>14.2 Exports: It is a compile-time error if a name &lt;i>N&lt;/i> is re-exported by a library\n&lt;i>L&lt;/i> and &lt;i>N&lt;/i> is introduced into the export namespace of &lt;i>L&lt;/i> by more than one\nexport, unless each all exports refer to same declaration for the name N.</p>\n<p>@param ambiguousElementName the name of the ambiguous element\n@param firstLibraryName the name of the first library that the type is found\n@param secondLibraryName the name of the second library that the type is found</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"ARGUMENT_DEFINITION_TEST_NON_PARAMETER":{"name":"ARGUMENT_DEFINITION_TEST_NON_PARAMETER","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.ARGUMENT_DEFINITION_TEST_NON_PARAMETER","comment":"<p>12.33 Argument Definition Test: It is a compile time error if &lt;i>v&lt;/i> does not denote a formal\nparameter.</p>\n<p>@param the name of the identifier in the argument definition test that is not a parameter</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"BUILT_IN_IDENTIFIER_AS_TYPE":{"name":"BUILT_IN_IDENTIFIER_AS_TYPE","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.BUILT_IN_IDENTIFIER_AS_TYPE","comment":"<p>12.30 Identifier Reference: It is a compile-time error to use a built-in identifier other than\ndynamic as a type annotation.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"BUILT_IN_IDENTIFIER_AS_TYPEDEF_NAME":{"name":"BUILT_IN_IDENTIFIER_AS_TYPEDEF_NAME","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.BUILT_IN_IDENTIFIER_AS_TYPEDEF_NAME","comment":"<p>12.30 Identifier Reference: It is a compile-time error if a built-in identifier is used as the\ndeclared name of a class, type parameter or type alias.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"BUILT_IN_IDENTIFIER_AS_TYPE_NAME":{"name":"BUILT_IN_IDENTIFIER_AS_TYPE_NAME","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.BUILT_IN_IDENTIFIER_AS_TYPE_NAME","comment":"<p>12.30 Identifier Reference: It is a compile-time error if a built-in identifier is used as the\ndeclared name of a class, type parameter or type alias.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"BUILT_IN_IDENTIFIER_AS_TYPE_PARAMETER_NAME":{"name":"BUILT_IN_IDENTIFIER_AS_TYPE_PARAMETER_NAME","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.BUILT_IN_IDENTIFIER_AS_TYPE_PARAMETER_NAME","comment":"<p>12.30 Identifier Reference: It is a compile-time error if a built-in identifier is used as the\ndeclared name of a class, type parameter or type alias.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CASE_EXPRESSION_TYPE_IMPLEMENTS_EQUALS":{"name":"CASE_EXPRESSION_TYPE_IMPLEMENTS_EQUALS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CASE_EXPRESSION_TYPE_IMPLEMENTS_EQUALS","comment":"<p>13.9 Switch: It is a compile-time error if the class &lt;i>C&lt;/i> implements the operator\n&lt;i>==&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"COMPILE_TIME_CONSTANT_RAISES_EXCEPTION":{"name":"COMPILE_TIME_CONSTANT_RAISES_EXCEPTION","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.COMPILE_TIME_CONSTANT_RAISES_EXCEPTION","comment":"<p>12.1 Constants: It is a compile-time error if evaluation of a compile-time constant would raise\nan exception.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONFLICTING_CONSTRUCTOR_NAME_AND_FIELD":{"name":"CONFLICTING_CONSTRUCTOR_NAME_AND_FIELD","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONFLICTING_CONSTRUCTOR_NAME_AND_FIELD","comment":"<p>7.6 Constructors: A constructor name always begins with the name of its immediately enclosing\nclass, and may optionally be followed by a dot and an identifier &lt;i>id&lt;/i>. It is a\ncompile-time error if &lt;i>id&lt;/i> is the name of a member declared in the immediately enclosing\nclass.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONFLICTING_CONSTRUCTOR_NAME_AND_METHOD":{"name":"CONFLICTING_CONSTRUCTOR_NAME_AND_METHOD","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONFLICTING_CONSTRUCTOR_NAME_AND_METHOD","comment":"<p>7.6 Constructors: A constructor name always begins with the name of its immediately enclosing\nclass, and may optionally be followed by a dot and an identifier &lt;i>id&lt;/i>. It is a\ncompile-time error if &lt;i>id&lt;/i> is the name of a member declared in the immediately enclosing\nclass.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONFLICTING_GETTER_AND_METHOD":{"name":"CONFLICTING_GETTER_AND_METHOD","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONFLICTING_GETTER_AND_METHOD","comment":"<p>7.2 Getters: It is a compile-time error if a class has both a getter and a method with the same\nname. This restriction holds regardless of whether the getter is defined explicitly or\nimplicitly, or whether the getter or the method are inherited or not.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONFLICTING_METHOD_AND_GETTER":{"name":"CONFLICTING_METHOD_AND_GETTER","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONFLICTING_METHOD_AND_GETTER","comment":"<p>7.2 Getters: It is a compile-time error if a class has both a getter and a method with the same\nname. This restriction holds regardless of whether the getter is defined explicitly or\nimplicitly, or whether the getter or the method are inherited or not.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONFLICTING_TYPE_VARIABLE_AND_CLASS":{"name":"CONFLICTING_TYPE_VARIABLE_AND_CLASS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONFLICTING_TYPE_VARIABLE_AND_CLASS","comment":"<ol><li>\n<p>Classes: It is a compile time error if a generic class declares a type variable with the\nsame name as the class or any of its members or constructors.</p></li></ol>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONFLICTING_TYPE_VARIABLE_AND_MEMBER":{"name":"CONFLICTING_TYPE_VARIABLE_AND_MEMBER","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONFLICTING_TYPE_VARIABLE_AND_MEMBER","comment":"<ol><li>\n<p>Classes: It is a compile time error if a generic class declares a type variable with the\nsame name as the class or any of its members or constructors.</p></li></ol>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_CONSTRUCTOR_THROWS_EXCEPTION":{"name":"CONST_CONSTRUCTOR_THROWS_EXCEPTION","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_CONSTRUCTOR_THROWS_EXCEPTION","comment":"<p>12.11.2 Const: It is a compile-time error if evaluation of a constant object results in an\nuncaught exception being thrown.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_CONSTRUCTOR_WITH_NON_CONST_SUPER":{"name":"CONST_CONSTRUCTOR_WITH_NON_CONST_SUPER","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_CONSTRUCTOR_WITH_NON_CONST_SUPER","comment":"<p>7.6.3 Constant Constructors: The superinitializer that appears, explicitly or implicitly, in\nthe initializer list of a constant constructor must specify a constant constructor of the\nsuperclass of the immediately enclosing class or a compile-time error occurs.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_CONSTRUCTOR_WITH_NON_FINAL_FIELD":{"name":"CONST_CONSTRUCTOR_WITH_NON_FINAL_FIELD","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_CONSTRUCTOR_WITH_NON_FINAL_FIELD","comment":"<p>7.6.3 Constant Constructors: It is a compile-time error if a constant constructor is declared\nby a class that has a non-final instance variable.</p>\n<p>The above refers to both locally declared and inherited instance variables.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_EVAL_THROWS_EXCEPTION":{"name":"CONST_EVAL_THROWS_EXCEPTION","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_EVAL_THROWS_EXCEPTION","comment":"<p>12.11.2 Const: It is a compile-time error if evaluation of a constant object results in an\nuncaught exception being thrown.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_EVAL_THROWS_IDBZE":{"name":"CONST_EVAL_THROWS_IDBZE","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_EVAL_THROWS_IDBZE","comment":"<p>12.11.2 Const: It is a compile-time error if evaluation of a constant object results in an\nuncaught exception being thrown.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_EVAL_TYPE_BOOL":{"name":"CONST_EVAL_TYPE_BOOL","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_EVAL_TYPE_BOOL","comment":"<p>12.11.2 Const: An expression of one of the forms !e, e1 &amp;&amp; e2 or e1 || e2, where e, e1 and e2\nare constant expressions that evaluate to a boolean value.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_EVAL_TYPE_BOOL_NUM_STRING":{"name":"CONST_EVAL_TYPE_BOOL_NUM_STRING","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_EVAL_TYPE_BOOL_NUM_STRING","comment":"<p>12.11.2 Const: An expression of one of the forms e1 == e2 or e1 != e2 where e1 and e2 are\nconstant expressions that evaluate to a numeric, string or boolean value or to null.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_EVAL_TYPE_INT":{"name":"CONST_EVAL_TYPE_INT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_EVAL_TYPE_INT","comment":"<p>12.11.2 Const: An expression of one of the forms ~e, e1 ^ e2, e1 &amp; e2, e1 | e2, e1 >> e2 or e1\n&lt;&lt; e2, where e, e1 and e2 are constant expressions that evaluate to an integer value or to\nnull.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_EVAL_TYPE_NUM":{"name":"CONST_EVAL_TYPE_NUM","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_EVAL_TYPE_NUM","comment":"<p>12.11.2 Const: An expression of one of the forms e, e1 + e2, e1 - e2, e1 * e2, e1 / e2, e1 ~/\ne2, e1 > e2, e1 &lt; e2, e1 >= e2, e1 &lt;= e2 or e1 % e2, where e, e1 and e2 are constant\nexpressions that evaluate to a numeric value or to null..</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_FIELD_INITIALIZER_NOT_ASSIGNABLE":{"name":"CONST_FIELD_INITIALIZER_NOT_ASSIGNABLE","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_FIELD_INITIALIZER_NOT_ASSIGNABLE","comment":"<p>7.6.1 Generative Constructors: In checked mode, it is a dynamic type error if o is not\n&lt;b>null&lt;/b> and the interface of the class of &lt;i>o&lt;/i> is not a subtype of the static type of\nthe field &lt;i>v&lt;/i>.</p>\n<p>12.11.2 Const: It is a compile-time error if evaluation of a constant object results in an\nuncaught exception being thrown.</p>\n<p>@param initializerType the name of the type of the initializer expression\n@param fieldType the name of the type of the field</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_FORMAL_PARAMETER":{"name":"CONST_FORMAL_PARAMETER","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_FORMAL_PARAMETER","comment":"<p>6.2 Formal Parameters: It is a compile-time error if a formal parameter is declared as a\nconstant variable.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE":{"name":"CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE","comment":"<p>5 Variables: A constant variable must be initialized to a compile-time constant or a\ncompile-time error occurs.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_INSTANCE_FIELD":{"name":"CONST_INSTANCE_FIELD","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_INSTANCE_FIELD","comment":"<p>7.5 Instance Variables: It is a compile-time error if an instance variable is declared to be\nconstant.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_MAP_KEY_EXPRESSION_TYPE_IMPLEMENTS_EQUALS":{"name":"CONST_MAP_KEY_EXPRESSION_TYPE_IMPLEMENTS_EQUALS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_MAP_KEY_EXPRESSION_TYPE_IMPLEMENTS_EQUALS","comment":"<p>12.8 Maps: It is a compile-time error if the key of an entry in a constant map literal is an\ninstance of a class that implements the operator &lt;i>==&lt;/i> unless the key is a string or\ninteger.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_NOT_INITIALIZED":{"name":"CONST_NOT_INITIALIZED","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_NOT_INITIALIZED","comment":"<p>5 Variables: A constant variable must be initialized to a compile-time constant (12.1) or a\ncompile-time error occurs.</p>\n<p>@param name the name of the uninitialized final variable</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_WITH_INVALID_TYPE_PARAMETERS":{"name":"CONST_WITH_INVALID_TYPE_PARAMETERS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_WITH_INVALID_TYPE_PARAMETERS","comment":"<p>12.11.2 Const: If &lt;i>T&lt;/i> is a parameterized type &lt;i>S&lt;U&lt;sub>1&lt;/sub>, &hellip;,\nU&lt;sub>m&lt;/sub>&gt;&lt;/i>, let &lt;i>R = S&lt;/i>; It is a compile time error if &lt;i>S&lt;/i> is not a\ngeneric type with &lt;i>m&lt;/i> type parameters.</p>\n<p>@param typeName the name of the type being referenced (&lt;i>S&lt;/i>)\n@param parameterCount the number of type parameters that were declared\n@param argumentCount the number of type arguments provided\n@see CompileTimeErrorCode#NEW<em>WITH</em>INVALID<em>TYPE</em>PARAMETERS\n@see StaticTypeWarningCode#WRONG<em>NUMBER</em>OF<em>TYPE</em>ARGUMENTS</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_WITH_NON_CONST":{"name":"CONST_WITH_NON_CONST","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_WITH_NON_CONST","comment":"<p>12.11.2 Const: If &lt;i>e&lt;/i> is of the form &lt;i>const T(a&lt;sub>1&lt;/sub>, &hellip;, a&lt;sub>n&lt;/sub>,\nx&lt;sub>n+1&lt;/sub>: a&lt;sub>n+1&lt;/sub>, &hellip;, x&lt;sub>n+k&lt;/sub>: a&lt;sub>n+k&lt;/sub>)&lt;/i> it is a\ncompile-time error if the type &lt;i>T&lt;/i> does not declare a constant constructor with the same\nname as the declaration of &lt;i>T&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_WITH_NON_CONSTANT_ARGUMENT":{"name":"CONST_WITH_NON_CONSTANT_ARGUMENT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_WITH_NON_CONSTANT_ARGUMENT","comment":"<p>12.11.2 Const: In all of the above cases, it is a compile-time error if &lt;i>a&lt;sub>i&lt;/sub>, 1\n&lt;= i &lt;= n + k&lt;/i>, is not a compile-time constant expression.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_WITH_NON_TYPE":{"name":"CONST_WITH_NON_TYPE","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_WITH_NON_TYPE","comment":"<p>12.11.2 Const: It is a compile-time error if &lt;i>T&lt;/i> is not a class accessible in the current\nscope, optionally followed by type arguments.</p>\n<p>12.11.2 Const: If &lt;i>e&lt;/i> is of the form &lt;i>const T.id(a&lt;sub>1&lt;/sub>, &hellip;, a&lt;sub>n&lt;/sub>,\nx&lt;sub>n+1&lt;/sub>: a&lt;sub>n+1&lt;/sub>, &hellip; x&lt;sub>n+k&lt;/sub>: a&lt;sub>n+k&lt;/sub>)&lt;/i> it is a\ncompile-time error if &lt;i>T&lt;/i> is not a class accessible in the current scope, optionally\nfollowed by type arguments.</p>\n<p>@param name the name of the non-type element</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_WITH_TYPE_PARAMETERS":{"name":"CONST_WITH_TYPE_PARAMETERS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_WITH_TYPE_PARAMETERS","comment":"<p>12.11.2 Const: It is a compile-time error if &lt;i>T&lt;/i> includes any type parameters.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_WITH_UNDEFINED_CONSTRUCTOR":{"name":"CONST_WITH_UNDEFINED_CONSTRUCTOR","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_WITH_UNDEFINED_CONSTRUCTOR","comment":"<p>12.11.2 Const: It is a compile-time error if &lt;i>T.id&lt;/i> is not the name of a constant\nconstructor declared by the type &lt;i>T&lt;/i>.</p>\n<p>@param typeName the name of the type\n@param constructorName the name of the requested constant constructor</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"CONST_WITH_UNDEFINED_CONSTRUCTOR_DEFAULT":{"name":"CONST_WITH_UNDEFINED_CONSTRUCTOR_DEFAULT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CONST_WITH_UNDEFINED_CONSTRUCTOR_DEFAULT","comment":"<p>12.11.2 Const: It is a compile-time error if &lt;i>T.id&lt;/i> is not the name of a constant\nconstructor declared by the type &lt;i>T&lt;/i>.</p>\n<p>@param typeName the name of the type</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"DEFAULT_VALUE_IN_FUNCTION_TYPED_PARAMETER":{"name":"DEFAULT_VALUE_IN_FUNCTION_TYPED_PARAMETER","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.DEFAULT_VALUE_IN_FUNCTION_TYPED_PARAMETER","comment":"<p>6.2.1 Required Formals: By means of a function signature that names the parameter and describes\nits type as a function type. It is a compile-time error if any default values are specified in\nthe signature of such a function type.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"DEFAULT_VALUE_IN_FUNCTION_TYPE_ALIAS":{"name":"DEFAULT_VALUE_IN_FUNCTION_TYPE_ALIAS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.DEFAULT_VALUE_IN_FUNCTION_TYPE_ALIAS","comment":"<p>15.3.1 Typedef: It is a compile-time error if any default values are specified in the signature\nof a function type alias.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"DEFAULT_VALUE_IN_REDIRECTING_FACTORY_CONSTRUCTOR":{"name":"DEFAULT_VALUE_IN_REDIRECTING_FACTORY_CONSTRUCTOR","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.DEFAULT_VALUE_IN_REDIRECTING_FACTORY_CONSTRUCTOR","comment":"<p>7.6.2 Factories: It is a compile-time error if &lt;i>k&lt;/i> explicitly specifies a default value\nfor an optional parameter.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"DUPLICATE_CONSTRUCTOR_DEFAULT":{"name":"DUPLICATE_CONSTRUCTOR_DEFAULT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.DUPLICATE_CONSTRUCTOR_DEFAULT","comment":"<p>3.1 Scoping: It is a compile-time error if there is more than one entity with the same name\ndeclared in the same scope.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"DUPLICATE_CONSTRUCTOR_NAME":{"name":"DUPLICATE_CONSTRUCTOR_NAME","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.DUPLICATE_CONSTRUCTOR_NAME","comment":"<p>3.1 Scoping: It is a compile-time error if there is more than one entity with the same name\ndeclared in the same scope.</p>\n<p>@param duplicateName the name of the duplicate entity</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"DUPLICATE_DEFINITION":{"name":"DUPLICATE_DEFINITION","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.DUPLICATE_DEFINITION","comment":"<p>3.1 Scoping: It is a compile-time error if there is more than one entity with the same name\ndeclared in the same scope.</p>\n<p>7 Classes: It is a compile-time error if a class declares two members of the same name.</p>\n<p>7 Classes: It is a compile-time error if a class has an instance member and a static member\nwith the same name.</p>\n<p>@param duplicateName the name of the duplicate entity</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"DUPLICATE_DEFINITION_INHERITANCE":{"name":"DUPLICATE_DEFINITION_INHERITANCE","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.DUPLICATE_DEFINITION_INHERITANCE","comment":"<ol><li>\n<p>Classes: It is a compile-time error if a class has an instance member and a static member\nwith the same name.</p></li></ol>\n<p>This covers the additional duplicate definition cases where inheritance has to be considered.</p>\n<p>@param className the name of the class that has conflicting instance/static members\n@param name the name of the conflicting members\n@see #DUPLICATE_DEFINITION</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"DUPLICATE_NAMED_ARGUMENT":{"name":"DUPLICATE_NAMED_ARGUMENT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.DUPLICATE_NAMED_ARGUMENT","comment":"<p>12.14.2 Binding Actuals to Formals: It is a compile-time error if &lt;i>q&lt;sub>i&lt;/sub> =\nq&lt;sub>j&lt;/sub>&lt;/i> for any &lt;i>i != j&lt;/i> where &lt;i>q&lt;sub>i&lt;/sub>&lt;/i> is the label for a named\nargument.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"EXPORT_INTERNAL_LIBRARY":{"name":"EXPORT_INTERNAL_LIBRARY","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.EXPORT_INTERNAL_LIBRARY","comment":"<p>SDK implementation libraries can be exported only by other SDK libraries.</p>\n<p>@param uri the uri pointing to a library</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"EXPORT_OF_NON_LIBRARY":{"name":"EXPORT_OF_NON_LIBRARY","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.EXPORT_OF_NON_LIBRARY","comment":"<p>14.2 Exports: It is a compile-time error if the compilation unit found at the specified URI is\nnot a library declaration.</p>\n<p>@param uri the uri pointing to a non-library declaration</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"EXTENDS_DISALLOWED_CLASS":{"name":"EXTENDS_DISALLOWED_CLASS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.EXTENDS_DISALLOWED_CLASS","comment":"<p>12.2 Null: It is a compile-time error for a class to attempt to extend or implement Null.</p>\n<p>12.3 Numbers: It is a compile-time error for a class to attempt to extend or implement int.</p>\n<p>12.3 Numbers: It is a compile-time error for a class to attempt to extend or implement double.</p>\n<p>12.3 Numbers: It is a compile-time error for any type other than the types int and double to\nattempt to extend or implement num.</p>\n<p>12.4 Booleans: It is a compile-time error for a class to attempt to extend or implement bool.</p>\n<p>12.5 Strings: It is a compile-time error for a class to attempt to extend or implement String.</p>\n<p>@param typeName the name of the type that cannot be extended\n@see #IMPLEMENTS<em>DISALLOWED</em>CLASS</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"EXTENDS_NON_CLASS":{"name":"EXTENDS_NON_CLASS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.EXTENDS_NON_CLASS","comment":"<p>7.9 Superclasses: It is a compile-time error if the extends clause of a class &lt;i>C&lt;/i> includes\na type expression that does not denote a class available in the lexical scope of &lt;i>C&lt;/i>.</p>\n<p>@param typeName the name of the superclass that was not found</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"EXTRA_POSITIONAL_ARGUMENTS":{"name":"EXTRA_POSITIONAL_ARGUMENTS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.EXTRA_POSITIONAL_ARGUMENTS","comment":"<p>12.14.2 Binding Actuals to Formals: It is a static warning if &lt;i>m &lt; h&lt;/i> or if &lt;i>m &gt;\nn&lt;/i>.</p>\n<p>12.11.2 Const: It is a compile-time error if evaluation of a constant object results in an\nuncaught exception being thrown.</p>\n<p>@param requiredCount the maximum number of positional arguments\n@param argumentCount the actual number of positional arguments given</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"FIELD_INITIALIZED_BY_MULTIPLE_INITIALIZERS":{"name":"FIELD_INITIALIZED_BY_MULTIPLE_INITIALIZERS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.FIELD_INITIALIZED_BY_MULTIPLE_INITIALIZERS","comment":"<p>7.6.1 Generative Constructors: Let &lt;i>k&lt;/i> be a generative constructor. It is a compile time\nerror if more than one initializer corresponding to a given instance variable appears in\n&lt;i>k&lt;/i>'s list.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"FIELD_INITIALIZED_IN_PARAMETER_AND_INITIALIZER":{"name":"FIELD_INITIALIZED_IN_PARAMETER_AND_INITIALIZER","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.FIELD_INITIALIZED_IN_PARAMETER_AND_INITIALIZER","comment":"<p>7.6.1 Generative Constructors: Let &lt;i>k&lt;/i> be a generative constructor. It is a compile time\nerror if &lt;i>k&lt;/i>'s initializer list contains an initializer for a variable that is initialized\nby means of an initializing formal of &lt;i>k&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"FIELD_INITIALIZER_FACTORY_CONSTRUCTOR":{"name":"FIELD_INITIALIZER_FACTORY_CONSTRUCTOR","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.FIELD_INITIALIZER_FACTORY_CONSTRUCTOR","comment":"<p>7.6.1 Generative Constructors: It is a compile-time error if an initializing formal is used by\na function other than a non-redirecting generative constructor.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"FIELD_INITIALIZER_OUTSIDE_CONSTRUCTOR":{"name":"FIELD_INITIALIZER_OUTSIDE_CONSTRUCTOR","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.FIELD_INITIALIZER_OUTSIDE_CONSTRUCTOR","comment":"<p>7.6.1 Generative Constructors: It is a compile-time error if an initializing formal is used by\na function other than a non-redirecting generative constructor.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"FIELD_INITIALIZER_REDIRECTING_CONSTRUCTOR":{"name":"FIELD_INITIALIZER_REDIRECTING_CONSTRUCTOR","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.FIELD_INITIALIZER_REDIRECTING_CONSTRUCTOR","comment":"<p>7.6.1 Generative Constructors: A generative constructor may be redirecting, in which case its\nonly action is to invoke another generative constructor.</p>\n<p>7.6.1 Generative Constructors: It is a compile-time error if an initializing formal is used by\na function other than a non-redirecting generative constructor.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"FINAL_INITIALIZED_MULTIPLE_TIMES":{"name":"FINAL_INITIALIZED_MULTIPLE_TIMES","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.FINAL_INITIALIZED_MULTIPLE_TIMES","comment":"<p>5 Variables: It is a compile-time error if a final instance variable that has is initialized by\nmeans of an initializing formal of a constructor is also initialized elsewhere in the same\nconstructor.</p>\n<p>@param name the name of the field in question</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"GETTER_AND_METHOD_WITH_SAME_NAME":{"name":"GETTER_AND_METHOD_WITH_SAME_NAME","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.GETTER_AND_METHOD_WITH_SAME_NAME","comment":"<p>7.2 Getters: It is a compile-time error if a class has both a getter and a method with the same\nname.</p>\n<p>@param name the conflicting name of the getter and method</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"IMPLEMENTS_DISALLOWED_CLASS":{"name":"IMPLEMENTS_DISALLOWED_CLASS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.IMPLEMENTS_DISALLOWED_CLASS","comment":"<p>12.2 Null: It is a compile-time error for a class to attempt to extend or implement Null.</p>\n<p>12.3 Numbers: It is a compile-time error for a class to attempt to extend or implement int.</p>\n<p>12.3 Numbers: It is a compile-time error for a class to attempt to extend or implement double.</p>\n<p>12.3 Numbers: It is a compile-time error for any type other than the types int and double to\nattempt to extend or implement num.</p>\n<p>12.4 Booleans: It is a compile-time error for a class to attempt to extend or implement bool.</p>\n<p>12.5 Strings: It is a compile-time error for a class to attempt to extend or implement String.</p>\n<p>@param typeName the name of the type that cannot be implemented\n@see #EXTENDS<em>DISALLOWED</em>CLASS</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"IMPLEMENTS_DYNAMIC":{"name":"IMPLEMENTS_DYNAMIC","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.IMPLEMENTS_DYNAMIC","comment":"<p>7.10 Superinterfaces: It is a compile-time error if the implements clause of a class includes\ntype dynamic.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"IMPLEMENTS_NON_CLASS":{"name":"IMPLEMENTS_NON_CLASS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.IMPLEMENTS_NON_CLASS","comment":"<p>7.10 Superinterfaces: It is a compile-time error if the implements clause of a class &lt;i>C&lt;/i>\nincludes a type expression that does not denote a class available in the lexical scope of\n&lt;i>C&lt;/i>.</p>\n<p>@param typeName the name of the interface that was not found</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"IMPLEMENTS_REPEATED":{"name":"IMPLEMENTS_REPEATED","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.IMPLEMENTS_REPEATED","comment":"<p>7.10 Superinterfaces: It is a compile-time error if a type &lt;i>T&lt;/i> appears more than once in\nthe implements clause of a class.</p>\n<p>@param className the name of the class that is implemented more than once</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"IMPLEMENTS_SUPER_CLASS":{"name":"IMPLEMENTS_SUPER_CLASS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.IMPLEMENTS_SUPER_CLASS","comment":"<p>7.10 Superinterfaces: It is a compile-time error if the superclass of a class &lt;i>C&lt;/i> appears\nin the implements clause of &lt;i>C&lt;/i>.</p>\n<p>@param className the name of the class that appears in both \"extends\" and \"implements\" clauses</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"IMPLICIT_THIS_REFERENCE_IN_INITIALIZER":{"name":"IMPLICIT_THIS_REFERENCE_IN_INITIALIZER","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.IMPLICIT_THIS_REFERENCE_IN_INITIALIZER","comment":"<p>7.6.1 Generative Constructors: Note that &lt;b>this&lt;/b> is not in scope on the right hand side of\nan initializer.</p>\n<p>12.10 This: It is a compile-time error if this appears in a top-level function or variable\ninitializer, in a factory constructor, or in a static method or variable initializer, or in the\ninitializer of an instance variable.</p>\n<p>@param name the name of the type in question</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"IMPORT_DEFERRED_LIBRARY_WITH_LOAD_FUNCTION":{"name":"IMPORT_DEFERRED_LIBRARY_WITH_LOAD_FUNCTION","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.IMPORT_DEFERRED_LIBRARY_WITH_LOAD_FUNCTION","comment":"<p>Speculative.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"IMPORT_INTERNAL_LIBRARY":{"name":"IMPORT_INTERNAL_LIBRARY","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.IMPORT_INTERNAL_LIBRARY","comment":"<p>SDK implementation libraries can be imported only by other SDK libraries.</p>\n<p>@param uri the uri pointing to a library</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"IMPORT_OF_NON_LIBRARY":{"name":"IMPORT_OF_NON_LIBRARY","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.IMPORT_OF_NON_LIBRARY","comment":"<p>14.1 Imports: It is a compile-time error if the compilation unit found at the specified URI is\nnot a library declaration.</p>\n<p>@param uri the uri pointing to a non-library declaration</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"INCONSISTENT_CASE_EXPRESSION_TYPES":{"name":"INCONSISTENT_CASE_EXPRESSION_TYPES","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.INCONSISTENT_CASE_EXPRESSION_TYPES","comment":"<p>13.9 Switch: It is a compile-time error if values of the expressions &lt;i>e&lt;sub>k&lt;/sub>&lt;/i> are\nnot instances of the same class &lt;i>C&lt;/i>, for all &lt;i>1 &lt;= k &lt;= n&lt;/i>.</p>\n<p>@param expressionSource the expression source code that is the unexpected type\n@param expectedType the name of the expected type</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"INITIALIZER_FOR_NON_EXISTANT_FIELD":{"name":"INITIALIZER_FOR_NON_EXISTANT_FIELD","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.INITIALIZER_FOR_NON_EXISTANT_FIELD","comment":"<p>7.6.1 Generative Constructors: Let &lt;i>k&lt;/i> be a generative constructor. It is a compile-time\nerror if &lt;i>k&lt;/i>'s initializer list contains an initializer for a variable that is not an\ninstance variable declared in the immediately surrounding class.</p>\n<p>@param id the name of the initializing formal that is not an instance variable in the</p>\n<pre><code>     immediately enclosing class\n</code></pre>\n<p>@see #INITIALIZING<em>FORMAL</em>FOR<em>NON</em>EXISTANT_FIELD</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"INITIALIZER_FOR_STATIC_FIELD":{"name":"INITIALIZER_FOR_STATIC_FIELD","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.INITIALIZER_FOR_STATIC_FIELD","comment":"<p>7.6.1 Generative Constructors: Let &lt;i>k&lt;/i> be a generative constructor. It is a compile-time\nerror if &lt;i>k&lt;/i>'s initializer list contains an initializer for a variable that is not an\ninstance variable declared in the immediately surrounding class.</p>\n<p>@param id the name of the initializing formal that is a static variable in the immediately</p>\n<pre><code>     enclosing class\n</code></pre>\n<p>@see #INITIALIZING<em>FORMAL</em>FOR<em>STATIC</em>FIELD</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"INITIALIZING_FORMAL_FOR_NON_EXISTANT_FIELD":{"name":"INITIALIZING_FORMAL_FOR_NON_EXISTANT_FIELD","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.INITIALIZING_FORMAL_FOR_NON_EXISTANT_FIELD","comment":"<p>7.6.1 Generative Constructors: An initializing formal has the form &lt;i>this.id&lt;/i>. It is a\ncompile-time error if &lt;i>id&lt;/i> is not the name of an instance variable of the immediately\nenclosing class.</p>\n<p>@param id the name of the initializing formal that is not an instance variable in the</p>\n<pre><code>     immediately enclosing class\n</code></pre>\n<p>@see #INITIALIZING<em>FORMAL</em>FOR<em>STATIC</em>FIELD\n@see #INITIALIZER<em>FOR</em>NON<em>EXISTANT</em>FIELD</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"INITIALIZING_FORMAL_FOR_STATIC_FIELD":{"name":"INITIALIZING_FORMAL_FOR_STATIC_FIELD","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.INITIALIZING_FORMAL_FOR_STATIC_FIELD","comment":"<p>7.6.1 Generative Constructors: An initializing formal has the form &lt;i>this.id&lt;/i>. It is a\ncompile-time error if &lt;i>id&lt;/i> is not the name of an instance variable of the immediately\nenclosing class.</p>\n<p>@param id the name of the initializing formal that is a static variable in the immediately</p>\n<pre><code>     enclosing class\n</code></pre>\n<p>@see #INITIALIZER<em>FOR</em>STATIC_FIELD</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"INSTANCE_MEMBER_ACCESS_FROM_STATIC":{"name":"INSTANCE_MEMBER_ACCESS_FROM_STATIC","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.INSTANCE_MEMBER_ACCESS_FROM_STATIC","comment":"<p>12.30 Identifier Reference: Otherwise, e is equivalent to the property extraction\n&lt;b>this&lt;/b>.&lt;i>id&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"INVALID_ANNOTATION":{"name":"INVALID_ANNOTATION","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.INVALID_ANNOTATION","comment":"<p>11 Metadata: Metadata consists of a series of annotations, each of which begin with the\ncharacter @, followed by a constant expression that must be either a reference to a\ncompile-time constant variable, or a call to a constant constructor.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"INVALID_CONSTANT":{"name":"INVALID_CONSTANT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.INVALID_CONSTANT","comment":"<p>TODO(brianwilkerson) Remove this when we have decided on how to report errors in compile-time\nconstants. Until then, this acts as a placeholder for more informative errors.</p>\n<p>See TODOs in ConstantVisitor</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"INVALID_CONSTRUCTOR_NAME":{"name":"INVALID_CONSTRUCTOR_NAME","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.INVALID_CONSTRUCTOR_NAME","comment":"<p>7.6 Constructors: It is a compile-time error if the name of a constructor is not a constructor\nname.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"INVALID_FACTORY_NAME_NOT_A_CLASS":{"name":"INVALID_FACTORY_NAME_NOT_A_CLASS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.INVALID_FACTORY_NAME_NOT_A_CLASS","comment":"<p>7.6.2 Factories: It is a compile-time error if &lt;i>M&lt;/i> is not the name of the immediately\nenclosing class.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"INVALID_REFERENCE_TO_THIS":{"name":"INVALID_REFERENCE_TO_THIS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.INVALID_REFERENCE_TO_THIS","comment":"<p>12.10 This: It is a compile-time error if this appears in a top-level function or variable\ninitializer, in a factory constructor, or in a static method or variable initializer, or in the\ninitializer of an instance variable.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"INVALID_TYPE_ARGUMENT_IN_CONST_LIST":{"name":"INVALID_TYPE_ARGUMENT_IN_CONST_LIST","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.INVALID_TYPE_ARGUMENT_IN_CONST_LIST","comment":"<p>12.6 Lists: It is a compile time error if the type argument of a constant list literal includes\na type parameter.</p>\n<p>@name the name of the type parameter</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"INVALID_TYPE_ARGUMENT_IN_CONST_MAP":{"name":"INVALID_TYPE_ARGUMENT_IN_CONST_MAP","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.INVALID_TYPE_ARGUMENT_IN_CONST_MAP","comment":"<p>12.7 Maps: It is a compile time error if the type arguments of a constant map literal include a\ntype parameter.</p>\n<p>@name the name of the type parameter</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"INVALID_URI":{"name":"INVALID_URI","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.INVALID_URI","comment":"<p>14.2 Exports: It is a compile-time error if the compilation unit found at the specified URI is\nnot a library declaration.</p>\n<p>14.1 Imports: It is a compile-time error if the compilation unit found at the specified URI is\nnot a library declaration.</p>\n<p>14.3 Parts: It is a compile time error if the contents of the URI are not a valid part\ndeclaration.</p>\n<p>@param uri the URI that is invalid\n@see #URI<em>DOES</em>NOT_EXIST</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"LABEL_IN_OUTER_SCOPE":{"name":"LABEL_IN_OUTER_SCOPE","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.LABEL_IN_OUTER_SCOPE","comment":"<p>13.13 Break: It is a compile-time error if no such statement &lt;i>s&lt;sub>E&lt;/sub>&lt;/i> exists within\nthe innermost function in which &lt;i>s&lt;sub>b&lt;/sub>&lt;/i> occurs.</p>\n<p>13.14 Continue: It is a compile-time error if no such statement or case clause\n&lt;i>s&lt;sub>E&lt;/sub>&lt;/i> exists within the innermost function in which &lt;i>s&lt;sub>c&lt;/sub>&lt;/i> occurs.</p>\n<p>@param labelName the name of the unresolvable label</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"LABEL_UNDEFINED":{"name":"LABEL_UNDEFINED","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.LABEL_UNDEFINED","comment":"<p>13.13 Break: It is a compile-time error if no such statement &lt;i>s&lt;sub>E&lt;/sub>&lt;/i> exists within\nthe innermost function in which &lt;i>s&lt;sub>b&lt;/sub>&lt;/i> occurs.</p>\n<p>13.14 Continue: It is a compile-time error if no such statement or case clause\n&lt;i>s&lt;sub>E&lt;/sub>&lt;/i> exists within the innermost function in which &lt;i>s&lt;sub>c&lt;/sub>&lt;/i> occurs.</p>\n<p>@param labelName the name of the unresolvable label</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"LIST_ELEMENT_TYPE_NOT_ASSIGNABLE":{"name":"LIST_ELEMENT_TYPE_NOT_ASSIGNABLE","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.LIST_ELEMENT_TYPE_NOT_ASSIGNABLE","comment":"<p>12.6 Lists: A run-time list literal &lt;&lt;i>E&lt;/i>&gt; &lt;i>e&lt;sub>1&lt;/sub>&lt;/i> ...\n&lt;i>e&lt;sub>n&lt;/sub>&lt;/i> is evaluated as follows:\n* The operator = is invoked on &lt;i>a&lt;/i> with first argument &lt;i>i&lt;/i> and second argument\n&lt;i>o&lt;sub>i+1&lt;/sub>&lt;/i>&lt;i>, 1 &lt;= i &lt;= n&lt;/i></p>\n<p>12.14.2 Binding Actuals to Formals: Let &lt;i>T&lt;sub>i&lt;/sub>&lt;/i> be the static type of\n&lt;i>a&lt;sub>i&lt;/sub>&lt;/i>, let &lt;i>S&lt;sub>i&lt;/sub>&lt;/i> be the type of &lt;i>p&lt;sub>i&lt;/sub>, 1 &lt;= i &lt;=\nn+k&lt;/i> and let &lt;i>S&lt;sub>q&lt;/sub>&lt;/i> be the type of the named parameter &lt;i>q&lt;/i> of &lt;i>f&lt;/i>.\nIt is a static warning if &lt;i>T&lt;sub>j&lt;/sub>&lt;/i> may not be assigned to &lt;i>S&lt;sub>j&lt;/sub>, 1 &lt;=\nj &lt;= m&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"MAP_KEY_TYPE_NOT_ASSIGNABLE":{"name":"MAP_KEY_TYPE_NOT_ASSIGNABLE","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.MAP_KEY_TYPE_NOT_ASSIGNABLE","comment":"<p>12.7 Map: A run-time map literal &lt;&lt;i>K&lt;/i>, &lt;i>V&lt;/i>&gt; &lt;i>k&lt;sub>1&lt;/sub>&lt;/i> :\n&lt;i>e&lt;sub>1&lt;/sub>&lt;/i> ... &lt;i>k&lt;sub>n&lt;/sub>&lt;/i> : &lt;i>e&lt;sub>n&lt;/sub>&lt;/i> is evaluated as follows:\n* The operator = is invoked on &lt;i>m&lt;/i> with first argument &lt;i>k&lt;sub>i&lt;/sub>&lt;/i> and second\nargument &lt;i>e&lt;sub>i&lt;/sub>&lt;/i>&lt;i>, 1 &lt;= i &lt;= n&lt;/i></p>\n<p>12.14.2 Binding Actuals to Formals: Let &lt;i>T&lt;sub>i&lt;/sub>&lt;/i> be the static type of\n&lt;i>a&lt;sub>i&lt;/sub>&lt;/i>, let &lt;i>S&lt;sub>i&lt;/sub>&lt;/i> be the type of &lt;i>p&lt;sub>i&lt;/sub>, 1 &lt;= i &lt;=\nn+k&lt;/i> and let &lt;i>S&lt;sub>q&lt;/sub>&lt;/i> be the type of the named parameter &lt;i>q&lt;/i> of &lt;i>f&lt;/i>.\nIt is a static warning if &lt;i>T&lt;sub>j&lt;/sub>&lt;/i> may not be assigned to &lt;i>S&lt;sub>j&lt;/sub>, 1 &lt;=\nj &lt;= m&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"MAP_VALUE_TYPE_NOT_ASSIGNABLE":{"name":"MAP_VALUE_TYPE_NOT_ASSIGNABLE","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.MAP_VALUE_TYPE_NOT_ASSIGNABLE","comment":"<p>12.7 Map: A run-time map literal &lt;&lt;i>K&lt;/i>, &lt;i>V&lt;/i>&gt; &lt;i>k&lt;sub>1&lt;/sub>&lt;/i> :\n&lt;i>e&lt;sub>1&lt;/sub>&lt;/i> ... &lt;i>k&lt;sub>n&lt;/sub>&lt;/i> : &lt;i>e&lt;sub>n&lt;/sub>&lt;/i> is evaluated as follows:\n* The operator = is invoked on &lt;i>m&lt;/i> with first argument &lt;i>k&lt;sub>i&lt;/sub>&lt;/i> and second\nargument &lt;i>e&lt;sub>i&lt;/sub>&lt;/i>&lt;i>, 1 &lt;= i &lt;= n&lt;/i></p>\n<p>12.14.2 Binding Actuals to Formals: Let &lt;i>T&lt;sub>i&lt;/sub>&lt;/i> be the static type of\n&lt;i>a&lt;sub>i&lt;/sub>&lt;/i>, let &lt;i>S&lt;sub>i&lt;/sub>&lt;/i> be the type of &lt;i>p&lt;sub>i&lt;/sub>, 1 &lt;= i &lt;=\nn+k&lt;/i> and let &lt;i>S&lt;sub>q&lt;/sub>&lt;/i> be the type of the named parameter &lt;i>q&lt;/i> of &lt;i>f&lt;/i>.\nIt is a static warning if &lt;i>T&lt;sub>j&lt;/sub>&lt;/i> may not be assigned to &lt;i>S&lt;sub>j&lt;/sub>, 1 &lt;=\nj &lt;= m&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"MEMBER_WITH_CLASS_NAME":{"name":"MEMBER_WITH_CLASS_NAME","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.MEMBER_WITH_CLASS_NAME","comment":"<p>7 Classes: It is a compile time error if a class &lt;i>C&lt;/i> declares a member with the same name\nas &lt;i>C&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"METHOD_AND_GETTER_WITH_SAME_NAME":{"name":"METHOD_AND_GETTER_WITH_SAME_NAME","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.METHOD_AND_GETTER_WITH_SAME_NAME","comment":"<p>7.2 Getters: It is a compile-time error if a class has both a getter and a method with the same\nname.</p>\n<p>@param name the conflicting name of the getter and method</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"MISSING_CONST_IN_LIST_LITERAL":{"name":"MISSING_CONST_IN_LIST_LITERAL","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.MISSING_CONST_IN_LIST_LITERAL","comment":"<p>12.1 Constants: A constant expression is ... a constant list literal.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"MISSING_CONST_IN_MAP_LITERAL":{"name":"MISSING_CONST_IN_MAP_LITERAL","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.MISSING_CONST_IN_MAP_LITERAL","comment":"<p>12.1 Constants: A constant expression is ... a constant map literal.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"MIXIN_DECLARES_CONSTRUCTOR":{"name":"MIXIN_DECLARES_CONSTRUCTOR","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.MIXIN_DECLARES_CONSTRUCTOR","comment":"<p>9 Mixins: It is a compile-time error if a declared or derived mixin explicitly declares a\nconstructor.</p>\n<p>@param typeName the name of the mixin that is invalid</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"MIXIN_INHERITS_FROM_NOT_OBJECT":{"name":"MIXIN_INHERITS_FROM_NOT_OBJECT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.MIXIN_INHERITS_FROM_NOT_OBJECT","comment":"<p>9 Mixins: It is a compile-time error if a mixin is derived from a class whose superclass is not\nObject.</p>\n<p>@param typeName the name of the mixin that is invalid</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"MIXIN_OF_DISALLOWED_CLASS":{"name":"MIXIN_OF_DISALLOWED_CLASS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.MIXIN_OF_DISALLOWED_CLASS","comment":"<p>12.2 Null: It is a compile-time error for a class to attempt to extend or implement Null.</p>\n<p>12.3 Numbers: It is a compile-time error for a class to attempt to extend or implement int.</p>\n<p>12.3 Numbers: It is a compile-time error for a class to attempt to extend or implement double.</p>\n<p>12.3 Numbers: It is a compile-time error for any type other than the types int and double to\nattempt to extend or implement num.</p>\n<p>12.4 Booleans: It is a compile-time error for a class to attempt to extend or implement bool.</p>\n<p>12.5 Strings: It is a compile-time error for a class to attempt to extend or implement String.</p>\n<p>@param typeName the name of the type that cannot be extended\n@see #IMPLEMENTS<em>DISALLOWED</em>CLASS</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"MIXIN_OF_NON_CLASS":{"name":"MIXIN_OF_NON_CLASS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.MIXIN_OF_NON_CLASS","comment":"<p>9.1 Mixin Application: It is a compile-time error if &lt;i>M&lt;/i> does not denote a class or mixin\navailable in the immediately enclosing scope.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"MIXIN_REFERENCES_SUPER":{"name":"MIXIN_REFERENCES_SUPER","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.MIXIN_REFERENCES_SUPER","comment":"<p>9 Mixins: It is a compile-time error if a declared or derived mixin refers to super.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"MIXIN_WITH_NON_CLASS_SUPERCLASS":{"name":"MIXIN_WITH_NON_CLASS_SUPERCLASS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.MIXIN_WITH_NON_CLASS_SUPERCLASS","comment":"<p>9.1 Mixin Application: It is a compile-time error if &lt;i>S&lt;/i> does not denote a class available\nin the immediately enclosing scope.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"MULTIPLE_REDIRECTING_CONSTRUCTOR_INVOCATIONS":{"name":"MULTIPLE_REDIRECTING_CONSTRUCTOR_INVOCATIONS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.MULTIPLE_REDIRECTING_CONSTRUCTOR_INVOCATIONS","comment":"<p>7.6.1 Generative Constructors: A generative constructor may be redirecting, in which case its\nonly action is to invoke another generative constructor.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"MULTIPLE_SUPER_INITIALIZERS":{"name":"MULTIPLE_SUPER_INITIALIZERS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.MULTIPLE_SUPER_INITIALIZERS","comment":"<p>7.6.1 Generative Constructors: Let &lt;i>k&lt;/i> be a generative constructor. Then &lt;i>k&lt;/i> may\ninclude at most one superinitializer in its initializer list or a compile time error occurs.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"NON_CONSTANT_ANNOTATION_CONSTRUCTOR":{"name":"NON_CONSTANT_ANNOTATION_CONSTRUCTOR","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.NON_CONSTANT_ANNOTATION_CONSTRUCTOR","comment":"<p>11 Metadata: Metadata consists of a series of annotations, each of which begin with the\ncharacter @, followed by a constant expression that must be either a reference to a\ncompile-time constant variable, or a call to a constant constructor.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"NON_CONSTANT_CASE_EXPRESSION":{"name":"NON_CONSTANT_CASE_EXPRESSION","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.NON_CONSTANT_CASE_EXPRESSION","comment":"<p>13.9 Switch: Given a switch statement of the form &lt;i>switch (e) { label&lt;sub>11&lt;/sub> &hellip;\nlabel&lt;sub>1j1&lt;/sub> case e&lt;sub>1&lt;/sub>: s&lt;sub>1&lt;/sub> &hellip; label&lt;sub>n1&lt;/sub> &hellip;\nlabel&lt;sub>njn&lt;/sub> case e&lt;sub>n&lt;/sub>: s&lt;sub>n&lt;/sub> default: s&lt;sub>n+1&lt;/sub>}&lt;/i> or the form\n&lt;i>switch (e) { label&lt;sub>11&lt;/sub> &hellip; label&lt;sub>1j1&lt;/sub> case e&lt;sub>1&lt;/sub>:\ns&lt;sub>1&lt;/sub> &hellip; label&lt;sub>n1&lt;/sub> &hellip; label&lt;sub>njn&lt;/sub> case e&lt;sub>n&lt;/sub>:\ns&lt;sub>n&lt;/sub>}&lt;/i>, it is a compile-time error if the expressions &lt;i>e&lt;sub>k&lt;/sub>&lt;/i> are not\ncompile-time constants, for all &lt;i>1 &lt;= k &lt;= n&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"NON_CONSTANT_DEFAULT_VALUE":{"name":"NON_CONSTANT_DEFAULT_VALUE","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.NON_CONSTANT_DEFAULT_VALUE","comment":"<p>6.2.2 Optional Formals: It is a compile-time error if the default value of an optional\nparameter is not a compile-time constant.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"NON_CONSTANT_LIST_ELEMENT":{"name":"NON_CONSTANT_LIST_ELEMENT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.NON_CONSTANT_LIST_ELEMENT","comment":"<p>12.6 Lists: It is a compile time error if an element of a constant list literal is not a\ncompile-time constant.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"NON_CONSTANT_MAP_KEY":{"name":"NON_CONSTANT_MAP_KEY","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.NON_CONSTANT_MAP_KEY","comment":"<p>12.7 Maps: It is a compile time error if either a key or a value of an entry in a constant map\nliteral is not a compile-time constant.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"NON_CONSTANT_MAP_VALUE":{"name":"NON_CONSTANT_MAP_VALUE","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.NON_CONSTANT_MAP_VALUE","comment":"<p>12.7 Maps: It is a compile time error if either a key or a value of an entry in a constant map\nliteral is not a compile-time constant.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"NON_CONSTANT_VALUE_IN_INITIALIZER":{"name":"NON_CONSTANT_VALUE_IN_INITIALIZER","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.NON_CONSTANT_VALUE_IN_INITIALIZER","comment":"<p>7.6.3 Constant Constructors: Any expression that appears within the initializer list of a\nconstant constructor must be a potentially constant expression, or a compile-time error occurs.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"NON_CONST_MAP_AS_EXPRESSION_STATEMENT":{"name":"NON_CONST_MAP_AS_EXPRESSION_STATEMENT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.NON_CONST_MAP_AS_EXPRESSION_STATEMENT","comment":"<p>13.2 Expression Statements: It is a compile-time error if a non-constant map literal that has\nno explicit type arguments appears in a place where a statement is expected.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"NON_GENERATIVE_CONSTRUCTOR":{"name":"NON_GENERATIVE_CONSTRUCTOR","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.NON_GENERATIVE_CONSTRUCTOR","comment":"<p>7.6.1 Generative Constructors: Let &lt;i>C&lt;/i> be the class in which the superinitializer appears\nand let &lt;i>S&lt;/i> be the superclass of &lt;i>C&lt;/i>. Let &lt;i>k&lt;/i> be a generative constructor. It is\na compile-time error if class &lt;i>S&lt;/i> does not declare a generative constructor named &lt;i>S&lt;/i>\n(respectively &lt;i>S.id&lt;/i>)</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"NOT_ENOUGH_REQUIRED_ARGUMENTS":{"name":"NOT_ENOUGH_REQUIRED_ARGUMENTS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.NOT_ENOUGH_REQUIRED_ARGUMENTS","comment":"<p>12.14.2 Binding Actuals to Formals: It is a static warning if &lt;i>m &lt; h&lt;/i> or if &lt;i>m > n&lt;/i>.</p>\n<p>12.11.2 Const: It is a compile-time error if evaluation of a constant object results in an\nuncaught exception being thrown.</p>\n<p>@param requiredCount the expected number of required arguments\n@param argumentCount the actual number of positional arguments given</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"NO_ANNOTATION_CONSTRUCTOR_ARGUMENTS":{"name":"NO_ANNOTATION_CONSTRUCTOR_ARGUMENTS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.NO_ANNOTATION_CONSTRUCTOR_ARGUMENTS","comment":"<p>11 Metadata: Metadata consists of a series of annotations, each of which begin with the\ncharacter @, followed by a constant expression that must be either a reference to a\ncompile-time constant variable, or a call to a constant constructor.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"NO_DEFAULT_SUPER_CONSTRUCTOR_EXPLICIT":{"name":"NO_DEFAULT_SUPER_CONSTRUCTOR_EXPLICIT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.NO_DEFAULT_SUPER_CONSTRUCTOR_EXPLICIT","comment":"<p>7.6.1 Generative Constructors: If no superinitializer is provided, an implicit superinitializer\nof the form &lt;b>super&lt;/b>() is added at the end of &lt;i>k&lt;/i>'s initializer list, unless the\nenclosing class is class &lt;i>Object&lt;/i>.</p>\n<p>7.6.1 Generative constructors. It is a compile-time error if class &lt;i>S&lt;/i> does not declare a\ngenerative constructor named &lt;i>S&lt;/i> (respectively &lt;i>S.id&lt;/i>)</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"NO_DEFAULT_SUPER_CONSTRUCTOR_IMPLICIT":{"name":"NO_DEFAULT_SUPER_CONSTRUCTOR_IMPLICIT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.NO_DEFAULT_SUPER_CONSTRUCTOR_IMPLICIT","comment":"<p>7.6 Constructors: Iff no constructor is specified for a class &lt;i>C&lt;/i>, it implicitly has a\ndefault constructor C() : &lt;b>super&lt;b>() {}, unless &lt;i>C&lt;/i> is class &lt;i>Object&lt;/i>.</p>\n<p>7.6.1 Generative constructors. It is a compile-time error if class &lt;i>S&lt;/i> does not declare a\ngenerative constructor named &lt;i>S&lt;/i> (respectively &lt;i>S.id&lt;/i>)</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"OBJECT_CANNOT_EXTEND_ANOTHER_CLASS":{"name":"OBJECT_CANNOT_EXTEND_ANOTHER_CLASS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.OBJECT_CANNOT_EXTEND_ANOTHER_CLASS","comment":"<p>7.9 Superclasses: It is a compile-time error to specify an extends clause for class Object.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"OPTIONAL_PARAMETER_IN_OPERATOR":{"name":"OPTIONAL_PARAMETER_IN_OPERATOR","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.OPTIONAL_PARAMETER_IN_OPERATOR","comment":"<p>7.1.1 Operators: It is a compile-time error to declare an optional parameter in an operator.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"PART_OF_NON_PART":{"name":"PART_OF_NON_PART","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.PART_OF_NON_PART","comment":"<p>14.3 Parts: It is a compile time error if the contents of the URI are not a valid part\ndeclaration.</p>\n<p>@param uri the uri pointing to a non-library declaration</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"PREFIX_COLLIDES_WITH_TOP_LEVEL_MEMBER":{"name":"PREFIX_COLLIDES_WITH_TOP_LEVEL_MEMBER","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.PREFIX_COLLIDES_WITH_TOP_LEVEL_MEMBER","comment":"<p>14.1 Imports: It is a compile-time error if the current library declares a top-level member\nnamed &lt;i>p&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"PRIVATE_OPTIONAL_PARAMETER":{"name":"PRIVATE_OPTIONAL_PARAMETER","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.PRIVATE_OPTIONAL_PARAMETER","comment":"<p>6.2.2 Optional Formals: It is a compile-time error if the name of a named optional parameter\nbegins with an '_' character.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"RECURSIVE_COMPILE_TIME_CONSTANT":{"name":"RECURSIVE_COMPILE_TIME_CONSTANT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.RECURSIVE_COMPILE_TIME_CONSTANT","comment":"<p>12.1 Constants: It is a compile-time error if the value of a compile-time constant expression\ndepends on itself.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"RECURSIVE_CONSTRUCTOR_REDIRECT":{"name":"RECURSIVE_CONSTRUCTOR_REDIRECT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.RECURSIVE_CONSTRUCTOR_REDIRECT","comment":"<p>7.6.1 Generative Constructors: A generative constructor may be redirecting, in which case its\nonly action is to invoke another generative constructor.</p>\n<p>TODO(scheglov) review this later, there are no explicit \"it is a compile-time error\" in\nspecification. But it was added to the co19 and there is same error for factories.</p>\n<p>https://code.google.com/p/dart/issues/detail?id=954</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"RECURSIVE_FACTORY_REDIRECT":{"name":"RECURSIVE_FACTORY_REDIRECT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.RECURSIVE_FACTORY_REDIRECT","comment":"<p>7.6.2 Factories: It is a compile-time error if a redirecting factory constructor redirects to\nitself, either directly or indirectly via a sequence of redirections.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"RECURSIVE_INTERFACE_INHERITANCE":{"name":"RECURSIVE_INTERFACE_INHERITANCE","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.RECURSIVE_INTERFACE_INHERITANCE","comment":"<p>7.10 Superinterfaces: It is a compile-time error if the interface of a class &lt;i>C&lt;/i> is a\nsuperinterface of itself.</p>\n<p>8.1 Superinterfaces: It is a compile-time error if an interface is a superinterface of itself.</p>\n<p>7.9 Superclasses: It is a compile-time error if a class &lt;i>C&lt;/i> is a superclass of itself.</p>\n<p>@param className the name of the class that implements itself recursively\n@param strImplementsPath a string representation of the implements loop</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_EXTENDS":{"name":"RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_EXTENDS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_EXTENDS","comment":"<p>7.10 Superinterfaces: It is a compile-time error if the interface of a class &lt;i>C&lt;/i> is a\nsuperinterface of itself.</p>\n<p>8.1 Superinterfaces: It is a compile-time error if an interface is a superinterface of itself.</p>\n<p>7.9 Superclasses: It is a compile-time error if a class &lt;i>C&lt;/i> is a superclass of itself.</p>\n<p>@param className the name of the class that implements itself recursively</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_IMPLEMENTS":{"name":"RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_IMPLEMENTS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_IMPLEMENTS","comment":"<p>7.10 Superinterfaces: It is a compile-time error if the interface of a class &lt;i>C&lt;/i> is a\nsuperinterface of itself.</p>\n<p>8.1 Superinterfaces: It is a compile-time error if an interface is a superinterface of itself.</p>\n<p>7.9 Superclasses: It is a compile-time error if a class &lt;i>C&lt;/i> is a superclass of itself.</p>\n<p>@param className the name of the class that implements itself recursively</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"REDIRECT_TO_MISSING_CONSTRUCTOR":{"name":"REDIRECT_TO_MISSING_CONSTRUCTOR","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.REDIRECT_TO_MISSING_CONSTRUCTOR","comment":"<p>7.6.2 Factories: It is a compile-time error if &lt;i>k&lt;/i> is prefixed with the const modifier but\n&lt;i>k'&lt;/i> is not a constant constructor.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"REDIRECT_TO_NON_CLASS":{"name":"REDIRECT_TO_NON_CLASS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.REDIRECT_TO_NON_CLASS","comment":"<p>7.6.2 Factories: It is a compile-time error if &lt;i>k&lt;/i> is prefixed with the const modifier but\n&lt;i>k'&lt;/i> is not a constant constructor.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"REDIRECT_TO_NON_CONST_CONSTRUCTOR":{"name":"REDIRECT_TO_NON_CONST_CONSTRUCTOR","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.REDIRECT_TO_NON_CONST_CONSTRUCTOR","comment":"<p>7.6.2 Factories: It is a compile-time error if &lt;i>k&lt;/i> is prefixed with the const modifier but\n&lt;i>k'&lt;/i> is not a constant constructor.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"REFERENCED_BEFORE_DECLARATION":{"name":"REFERENCED_BEFORE_DECLARATION","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.REFERENCED_BEFORE_DECLARATION","comment":"<p>5 Variables: A local variable may only be referenced at a source code location that is after\nits initializer, if any, is complete, or a compile-time error occurs.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"RETHROW_OUTSIDE_CATCH":{"name":"RETHROW_OUTSIDE_CATCH","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.RETHROW_OUTSIDE_CATCH","comment":"<p>12.8.1 Rethrow: It is a compile-time error if an expression of the form &lt;i>rethrow;&lt;/i> is not\nenclosed within a on-catch clause.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"RETURN_IN_GENERATIVE_CONSTRUCTOR":{"name":"RETURN_IN_GENERATIVE_CONSTRUCTOR","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.RETURN_IN_GENERATIVE_CONSTRUCTOR","comment":"<p>13.12 Return: It is a compile-time error if a return statement of the form &lt;i>return e;&lt;/i>\nappears in a generative constructor.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"SHARED_DEFERRED_PREFIX":{"name":"SHARED_DEFERRED_PREFIX","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.SHARED_DEFERRED_PREFIX","comment":"<p>Speculative.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"SUPER_INITIALIZER_IN_OBJECT":{"name":"SUPER_INITIALIZER_IN_OBJECT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.SUPER_INITIALIZER_IN_OBJECT","comment":"<p>7.6.1 Generative Constructors: Let &lt;i>k&lt;/i> be a generative constructor. It is a compile-time\nerror if a generative constructor of class Object includes a superinitializer.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"SUPER_IN_INVALID_CONTEXT":{"name":"SUPER_IN_INVALID_CONTEXT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.SUPER_IN_INVALID_CONTEXT","comment":"<p>12.15.4 Super Invocation: A super method invocation &lt;i>i&lt;/i> has the form\n&lt;i>super.m(a&lt;sub>1&lt;/sub>, &hellip;, a&lt;sub>n&lt;/sub>, x&lt;sub>n+1&lt;/sub>: a&lt;sub>n+1&lt;/sub>, &hellip;\nx&lt;sub>n+k&lt;/sub>: a&lt;sub>n+k&lt;/sub>)&lt;/i>. It is a compile-time error if a super method invocation\noccurs in a top-level function or variable initializer, in an instance variable initializer or\ninitializer list, in class Object, in a factory constructor, or in a static method or variable\ninitializer.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"SUPER_IN_REDIRECTING_CONSTRUCTOR":{"name":"SUPER_IN_REDIRECTING_CONSTRUCTOR","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.SUPER_IN_REDIRECTING_CONSTRUCTOR","comment":"<p>7.6.1 Generative Constructors: A generative constructor may be redirecting, in which case its\nonly action is to invoke another generative constructor.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"TYPE_ALIAS_CANNOT_REFERENCE_ITSELF":{"name":"TYPE_ALIAS_CANNOT_REFERENCE_ITSELF","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.TYPE_ALIAS_CANNOT_REFERENCE_ITSELF","comment":"<p>15.3.1 Typedef: Any self reference, either directly, or recursively via another typedef, is a\ncompile time error.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"TYPE_ARGUMENT_NOT_MATCHING_BOUNDS":{"name":"TYPE_ARGUMENT_NOT_MATCHING_BOUNDS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.TYPE_ARGUMENT_NOT_MATCHING_BOUNDS","comment":"<p>12.11 Instance Creation: It is a static type warning if any of the type arguments to a\nconstructor of a generic type &lt;i>G&lt;/i> invoked by a new expression or a constant object\nexpression are not subtypes of the bounds of the corresponding formal type parameters of\n&lt;i>G&lt;/i>.</p>\n<p>12.11.1 New: If T is malformed a dynamic error occurs. In checked mode, if T is mal-bounded a\ndynamic error occurs.</p>\n<p>12.1 Constants: It is a compile-time error if evaluation of a compile-time constant would raise\nan exception.</p>\n<p>@param boundedTypeName the name of the type used in the instance creation that should be</p>\n<pre><code>     limited by the bound as specified in the class declaration\n</code></pre>\n<p>@param boundingTypeName the name of the bounding type\n@see StaticTypeWarningCode#TYPE<em>ARGUMENT</em>NOT<em>MATCHING</em>BOUNDS</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"UNDEFINED_CLASS":{"name":"UNDEFINED_CLASS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.UNDEFINED_CLASS","comment":"<p>12.11.2 Const: It is a compile-time error if &lt;i>T&lt;/i> is not a class accessible in the current\nscope, optionally followed by type arguments.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"UNDEFINED_CONSTRUCTOR_IN_INITIALIZER":{"name":"UNDEFINED_CONSTRUCTOR_IN_INITIALIZER","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.UNDEFINED_CONSTRUCTOR_IN_INITIALIZER","comment":"<p>7.6.1 Generative Constructors: Let &lt;i>C&lt;/i> be the class in which the superinitializer appears\nand let &lt;i>S&lt;/i> be the superclass of &lt;i>C&lt;/i>. Let &lt;i>k&lt;/i> be a generative constructor. It is\na compile-time error if class &lt;i>S&lt;/i> does not declare a generative constructor named &lt;i>S&lt;/i>\n(respectively &lt;i>S.id&lt;/i>)</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"UNDEFINED_CONSTRUCTOR_IN_INITIALIZER_DEFAULT":{"name":"UNDEFINED_CONSTRUCTOR_IN_INITIALIZER_DEFAULT","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.UNDEFINED_CONSTRUCTOR_IN_INITIALIZER_DEFAULT","comment":"<p>7.6.1 Generative Constructors: Let &lt;i>C&lt;/i> be the class in which the superinitializer appears\nand let &lt;i>S&lt;/i> be the superclass of &lt;i>C&lt;/i>. Let &lt;i>k&lt;/i> be a generative constructor. It is\na compile-time error if class &lt;i>S&lt;/i> does not declare a generative constructor named &lt;i>S&lt;/i>\n(respectively &lt;i>S.id&lt;/i>)</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"UNDEFINED_NAMED_PARAMETER":{"name":"UNDEFINED_NAMED_PARAMETER","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.UNDEFINED_NAMED_PARAMETER","comment":"<p>12.14.2 Binding Actuals to Formals: Furthermore, each &lt;i>q&lt;sub>i&lt;/sub>&lt;/i>, &lt;i>1&lt;=i&lt;=l&lt;/i>,\nmust have a corresponding named parameter in the set {&lt;i>p&lt;sub>n+1&lt;/sub>&lt;/i> ...\n&lt;i>p&lt;sub>n+k&lt;/sub>&lt;/i>} or a static warning occurs.</p>\n<p>12.11.2 Const: It is a compile-time error if evaluation of a constant object results in an\nuncaught exception being thrown.</p>\n<p>@param name the name of the requested named parameter</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"URI_DOES_NOT_EXIST":{"name":"URI_DOES_NOT_EXIST","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.URI_DOES_NOT_EXIST","comment":"<p>14.2 Exports: It is a compile-time error if the compilation unit found at the specified URI is\nnot a library declaration.</p>\n<p>14.1 Imports: It is a compile-time error if the compilation unit found at the specified URI is\nnot a library declaration.</p>\n<p>14.3 Parts: It is a compile time error if the contents of the URI are not a valid part\ndeclaration.</p>\n<p>@param uri the URI pointing to a non-existent file\n@see #INVALID_URI</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"URI_WITH_INTERPOLATION":{"name":"URI_WITH_INTERPOLATION","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.URI_WITH_INTERPOLATION","comment":"<p>14.1 Imports: It is a compile-time error if &lt;i>x&lt;/i> is not a compile-time constant, or if\n&lt;i>x&lt;/i> involves string interpolation.</p>\n<p>14.3 Parts: It is a compile-time error if &lt;i>s&lt;/i> is not a compile-time constant, or if\n&lt;i>s&lt;/i> involves string interpolation.</p>\n<p>14.5 URIs: It is a compile-time error if the string literal &lt;i>x&lt;/i> that describes a URI is\nnot a compile-time constant, or if &lt;i>x&lt;/i> involves string interpolation.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR":{"name":"WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR","comment":"<p>7.1.1 Operators: It is a compile-time error if the arity of the user-declared operator = is\nnot 2. It is a compile time error if the arity of a user-declared operator with one of the\nnames: &lt;, &gt;, &lt;=, &gt;=, ==, +, /, ~/, *, %, |, ^, &amp;, &lt;&lt;, &gt;&gt;,  is not 1.\nIt is a compile time error if the arity of the user-declared operator - is not 0 or 1. It is a\ncompile time error if the arity of the user-declared operator ~ is not 0.</p>\n<p>@param operatorName the name of the declared operator\n@param expectedNumberOfParameters the number of parameters expected\n@param actualNumberOfParameters the number of parameters found in the operator declaration</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR_MINUS":{"name":"WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR_MINUS","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR_MINUS","comment":"<p>7.1.1 Operators: It is a compile time error if the arity of the user-declared operator - is not\n0 or 1.</p>\n<p>@param actualNumberOfParameters the number of parameters found in the operator declaration</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"WRONG_NUMBER_OF_PARAMETERS_FOR_SETTER":{"name":"WRONG_NUMBER_OF_PARAMETERS_FOR_SETTER","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.WRONG_NUMBER_OF_PARAMETERS_FOR_SETTER","comment":"<p>7.3 Setters: It is a compile-time error if a setter's formal parameter list does not include\nexactly one required formal parameter &lt;i>p&lt;/i>.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}],"annotations":[]},"correction":{"name":"correction","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.correction","comment":"<p>The template used to create the correction to be displayed for this error, or <code>null</code> if\nthere is no correction information for this error.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"message":{"name":"message","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.message","comment":"<p>The template used to create the message to be displayed for this error.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"values":{"name":"values","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.values","comment":"","final":false,"static":true,"constant":true,"type":[{"outer":"dart-core.List","inner":[{"outer":"analyzer/analyzer.CompileTimeErrorCode","inner":[]}]}],"annotations":[]}},"inheritedVariables":{"name":{"name":"name","qualifiedName":"analyzer/analyzer.Enum.name","comment":"<p>The name of this enum constant, as declared in the enum declaration.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"ordinal":{"name":"ordinal","qualifiedName":"analyzer/analyzer.Enum.ordinal","comment":"<p>The position in the enum declaration.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.int","inner":[]}],"annotations":[]}},"methods":{"setters":{},"getters":{"errorSeverity":{"name":"errorSeverity","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.errorSeverity","comment":"<p>Return the severity of this error.</p>\n<p>@return the severity of this error</p>","commentFrom":"analyzer.ErrorCode.errorSeverity","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/analyzer.ErrorSeverity","inner":[]}],"parameters":{},"annotations":[{"name":"analyzer/dart-core.override","parameters":[]}]},"type":{"name":"type","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.type","comment":"<p>Return the type of the error.</p>\n<p>@return the type of the error</p>","commentFrom":"analyzer.ErrorCode.type","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"analyzer/analyzer.ErrorType","inner":[]}],"parameters":{},"annotations":[{"name":"analyzer/dart-core.override","parameters":[]}]}},"constructors":{"con1":{"name":"con1","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CompileTimeErrorCode-con1","comment":"<p>Initialize a newly created error code to have the given message.</p>\n<p>@param message the message template used to create the message to be displayed for the error</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":true,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"ordinal":{"name":"ordinal","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"con2":{"name":"con2","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.CompileTimeErrorCode-con2","comment":"<p>Initialize a newly created error code to have the given message and correction.</p>\n<p>@param message the template used to create the message to be displayed for the error\n@param correction the template used to create the correction to be displayed for the error</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":true,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"ordinal":{"name":"ordinal","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"correction":{"name":"correction","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{},"methods":{}},"inheritedMethods":{"setters":{},"getters":{"correction":{"name":"correction","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.correction","comment":"<p>Return the template used to create the correction to be displayed for this error, or\n<code>null</code> if there is no correction information for this error. The correction should\nindicate how the user can fix the error.</p>\n<p>@return the template used to create the correction to be displayed for this error</p>","commentFrom":"","inheritedFrom":"analyzer.ErrorCode.correction","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"errorSeverity":{"name":"errorSeverity","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.errorSeverity","comment":"<p>Return the severity of this error.</p>\n<p>@return the severity of this error</p>","commentFrom":"","inheritedFrom":"analyzer.ErrorCode.errorSeverity","static":false,"abstract":true,"constant":false,"return":[{"outer":"analyzer/analyzer.ErrorSeverity","inner":[]}],"parameters":{},"annotations":[]},"hashCode":{"name":"hashCode","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>analyzer/analyzer.CompileTimeErrorCode.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"message":{"name":"message","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.message","comment":"<p>Return the template used to create the message to be displayed for this error. The message\nshould indicate what is wrong and why it is wrong.</p>\n<p>@return the template used to create the message to be displayed for this error</p>","commentFrom":"","inheritedFrom":"analyzer.ErrorCode.message","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]},"type":{"name":"type","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.type","comment":"<p>Return the type of the error.</p>\n<p>@return the type of the error</p>","commentFrom":"","inheritedFrom":"analyzer.ErrorCode.type","static":false,"abstract":true,"constant":false,"return":[{"outer":"analyzer/analyzer.ErrorType","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>analyzer/analyzer.CompileTimeErrorCode.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>analyzer/analyzer.CompileTimeErrorCode.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"compareTo":{"name":"compareTo","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.compareTo","comment":"<p>Compares this object to another <a>dart-core.Comparable</a></p>\n<p>Returns a value like a <a>dart-core.Comparator</a> when comparing <code>this</code> to <a>analyzer/analyzer.CompileTimeErrorCode.compareTo.other</a>.\nThat is, it returns a negative integer if <code>this</code> is ordered before <a>analyzer/analyzer.CompileTimeErrorCode.compareTo.other</a>,\na positive integer if <code>this</code> is ordered after <a>analyzer/analyzer.CompileTimeErrorCode.compareTo.other</a>,\nand zero if <code>this</code> and <a>analyzer/analyzer.CompileTimeErrorCode.compareTo.other</a> are ordered together.</p>\n<p>The <a>analyzer/analyzer.CompileTimeErrorCode.compareTo.other</a> argument must be a value that is comparable to this object.</p>","commentFrom":"dart-core.Comparable.compareTo","inheritedFrom":"analyzer.Enum.compareTo","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"analyzer/analyzer.Enum.E","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.noSuchMethod","comment":"<p><a>analyzer/analyzer.CompileTimeErrorCode.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>analyzer/analyzer.CompileTimeErrorCode.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>analyzer/analyzer.CompileTimeErrorCode.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>analyzer/analyzer.CompileTimeErrorCode.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"analyzer/analyzer.CompileTimeErrorCode.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}